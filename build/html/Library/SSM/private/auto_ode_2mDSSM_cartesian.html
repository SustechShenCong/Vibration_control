
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><body><div class="banner"><a href="../../../index.html"><img alt="Logo" class="logo" src="../../../logo.png" style="float:right" width="200"/></a></div><html><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--

                    This HTML was auto-generated from MATLAB code.
                    To make changes, update the MATLAB code and republish this document.
                --><title>AUTO_ODE_2MDSSM_CARTESIAN</title><meta content="MATLAB 9.14" name="generator"/><link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/><meta content="2023-09-11" name="DC.date"/><meta content="auto_ode_2mDSSM_cartesian.m" name="DC.source"/><style type="text/css">
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

            html { min-height:100%; margin-bottom:1px; }
            html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
            html body td { vertical-align:top; text-align:left; }

            h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
            h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
            h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

            a { color:#005fce; text-decoration:none; }
            a:hover { color:#005fce; text-decoration:underline; }
            a:visited { color:#004aa0; text-decoration:none; }

            p { padding:0px; margin:0px 0px 20px; }
            img { padding:0px; margin:0px 0px 20px; border:none; }
            p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

            ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
            ul li { padding:0px; margin:0px 0px 7px 0px; }
            ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
            ul li ol li { list-style:decimal; }
            ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
            ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
            ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
            ol li ol li { list-style-type:lower-alpha; }
            ol li ul { padding-top:7px; }
            ol li ul li { list-style:square; }

            .content { font-size:1.2em; line-height:140%; padding: 20px; }

            pre, code { font-size:12px; }
            tt { font-size: 1.2em; }
            pre { margin:0px 0px 20px; }
            pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
            pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
            pre.error { color:red; }

            @media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

            span.keyword { color:#0000FF }
            span.comment { color:#228B22 }
            span.string { color:#A020F0 }
            span.untermstring { color:#B20000 }
            span.syscmd { color:#B28C00 }
            span.typesection { color:#A0522D }

            .footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
            .footer p { margin:0px; }
            .footer a { color:#878787; }
            .footer a:hover { color:#878787; text-decoration:underline; }
            .footer a:visited { color:#878787; }

            table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
            table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

            .center {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 50%;
              }



        </style></head><body><div class="content"><h1>AUTO_ODE_2MDSSM_CARTESIAN</h1><!--introduction--><!--/introduction--><pre class="codeinput"><span class="keyword">function</span> y = auto_<a href="../../../Library/SSM/private/ode_2mDSSM_cartesian.html">ode_2mDSSM_cartesian</a>(z, data)
        </pre><p>This function presents vectorized implementation of vector field of reduced dynamics on 2m-dimensional SSMs. Here z is a 2m-dimensional state vector and p is parameter vector for excitation frequency and amplitude. All other info such as eigenvalues of master spectral subspace, coefficients of nonlinear terms is included in the structure data. The state vector here is in the form of Cartesian coordinates.</p><p>See also: ODE_2MDSSM_POLAR</p><pre class="codeinput">assert(~isempty(data), <span class="string">'Structure data in ode_2mDSSM_cartesian is empty'</span>);
<span class="comment">% extract data fields</span>
beta   = data.beta;
kappa  = data.kappa;
lamdRe = data.lamdRe;
lamdIm = data.lamdIm;

<span class="comment">% rename state and parameter</span>
zRe  = z(1:2:end-1,:);
zIm  = z(2:2:end,:);
zcomp = zRe+1i*zIm; <span class="comment">% qs in formulation</span>
zconj = conj(zcomp);

<span class="comment">% autonomous linear part</span>
yRe = lamdRe.*zRe-lamdIm.*zIm;
yIm = lamdRe.*zIm+lamdIm.*zRe;

<span class="comment">% autonomous nonlinear part</span>
m  = numel(lamdRe);
<span class="keyword">for</span> i=1:m
    kappai = kappa{i};
    kappai = full(kappai);
    betai  = beta{i};
    nka = size(kappai,1);
    nbe = numel(betai);
    assert(nka==nbe, <span class="string">'Size of kappa%d and beta%d does not match'</span>,i,i);
    <span class="keyword">for</span> k=1:nka
        ka = kappai(k,:);
        be = betai(k);
        l = ka(1:2:end-1)';
        j = ka(2:2:end)';
        zk = be*prod(zcomp.^l.*zconj.^j,1);
        yRe(i,:) = yRe(i,:)+real(zk);
        yIm(i,:) = yIm(i,:)+imag(zk);
    <span class="keyword">end</span>
<span class="keyword">end</span>

nt = size(z,2);
y  = zeros(2*m,nt);
y(1:2:end-1,:) = yRe;
y(2:2:end,:)   = yIm;
        </pre><pre class="codeinput"><span class="keyword">end</span>
        </pre><p class="footer"><br/><a href="https://www.mathworks.com/products/matlab/">Published with MATLABÂ® R2023a</a><br/></p></div><!--
            ##### SOURCE BEGIN #####
            %% AUTO_ODE_2MDSSM_CARTESIAN
%
%%
function y = auto_<a href="../../../Library/SSM/private/ode_2mDSSM_cartesian.html">ode_2mDSSM_cartesian</a>(z, data)
%%
% This function presents vectorized implementation of vector
% field of reduced dynamics on 2m-dimensional SSMs. Here z is a
% 2m-dimensional state vector and p is parameter vector for excitation
% frequency and amplitude. All other info such as eigenvalues of master
% spectral subspace, coefficients of nonlinear terms is included in the
% structure data. The state vector here is in the form of Cartesian
% coordinates.
%
% See also: ODE_2MDSSM_POLAR

assert(~isempty(data), 'Structure data in ode_2mDSSM_cartesian is empty');
% extract data fields
beta   = data.beta;
kappa  = data.kappa;
lamdRe = data.lamdRe;
lamdIm = data.lamdIm;

% rename state and parameter
zRe  = z(1:2:end-1,:);
zIm  = z(2:2:end,:);
zcomp = zRe+1i*zIm; % qs in formulation
zconj = conj(zcomp);

% autonomous linear part
yRe = lamdRe.*zRe-lamdIm.*zIm;
yIm = lamdRe.*zIm+lamdIm.*zRe;

% autonomous nonlinear part
m  = numel(lamdRe);
for i=1:m
    kappai = kappa{i};
    kappai = full(kappai);
    betai  = beta{i};
    nka = size(kappai,1);
    nbe = numel(betai);
    assert(nka==nbe, 'Size of kappa%d and beta%d does not match',i,i);
    for k=1:nka
        ka = kappai(k,:);
        be = betai(k);
        l = ka(1:2:end-1)';
        j = ka(2:2:end)';
        zk = be*prod(zcomp.^l.*zconj.^j,1);
        yRe(i,:) = yRe(i,:)+real(zk);
        yIm(i,:) = yIm(i,:)+imag(zk);
    end
end

nt = size(z,2);
y  = zeros(2*m,nt);
y(1:2:end-1,:) = yRe;
y(2:2:end,:)   = yIm;

end
            ##### SOURCE END #####
        --></body></html></body></html>