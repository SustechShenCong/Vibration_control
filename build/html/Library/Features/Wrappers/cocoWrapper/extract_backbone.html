
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><body><div class="banner"><a href="../../../../index.html"><img alt="Logo" class="logo" src="../../../../logo.png" style="float:right" width="200"/></a></div><html><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--

                    This HTML was auto-generated from MATLAB code.
                    To make changes, update the MATLAB code and republish this document.
                --><title>EXTRACT_BACKBONE</title><meta content="MATLAB 9.14" name="generator"/><link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/><meta content="2023-09-09" name="DC.date"/><meta content="extract_backbone.m" name="DC.source"/><style type="text/css">
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

            html { min-height:100%; margin-bottom:1px; }
            html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
            html body td { vertical-align:top; text-align:left; }

            h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
            h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
            h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

            a { color:#005fce; text-decoration:none; }
            a:hover { color:#005fce; text-decoration:underline; }
            a:visited { color:#004aa0; text-decoration:none; }

            p { padding:0px; margin:0px 0px 20px; }
            img { padding:0px; margin:0px 0px 20px; border:none; }
            p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

            ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
            ul li { padding:0px; margin:0px 0px 7px 0px; }
            ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
            ul li ol li { list-style:decimal; }
            ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
            ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
            ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
            ol li ol li { list-style-type:lower-alpha; }
            ol li ul { padding-top:7px; }
            ol li ul li { list-style:square; }

            .content { font-size:1.2em; line-height:140%; padding: 20px; }

            pre, code { font-size:12px; }
            tt { font-size: 1.2em; }
            pre { margin:0px 0px 20px; }
            pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
            pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
            pre.error { color:red; }

            @media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

            span.keyword { color:#0000FF }
            span.comment { color:#228B22 }
            span.string { color:#A020F0 }
            span.untermstring { color:#B20000 }
            span.syscmd { color:#B28C00 }
            span.typesection { color:#A0522D }

            .footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
            .footer p { margin:0px; }
            .footer a { color:#878787; }
            .footer a:hover { color:#878787; text-decoration:underline; }
            .footer a:visited { color:#878787; }

            table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
            table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

            .center {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 50%;
              }



        </style></head><body><div class="content"><h1>EXTRACT_BACKBONE</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Extract backbone</a></li><li><a href="#3">Setup</a></li><li><a href="#4">Loop over orders</a></li><li><a href="#5">Compute autonomous SSM coefficients</a></li><li><a href="#6">Compute backbone</a></li><li><a href="#7">Backbone curves in Physical Coordinates</a></li><li><a href="#8">Plotting</a></li><li><a href="#11">Compute grid</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> BB = extract_backbone(obj, modes, omegaRange, order, varargin)
        </pre><h2 id="2">Extract backbone</h2><p>This function extracts the <b>Backbone Curves in polar coordinates.</b> For two-dimensional SSMs, we use the normal form of paramaterization, where we choose the following form of autonomous reduced dynamics as</p><p><span class="MathJax_Preview"><img alt="$$\mathbf{R}_{0}(\mathbf{p})=\left[\begin{array}{c}\lambda p\\\bar{\lambda}\bar{p}\end{array}\right]+\sum_{j=1}^{M}\left[\begin{array}{c}\gamma_{j}p^{j+1}\bar{p}^{j}\\\bar{\gamma}_{j}p^{j}\bar{p}^{j+1}\end{array}\right],$$" src="extract_backbone_eq08701743399208904152-Rescaled.png" style="width: 211.2px; height: auto;"/></span><script type="math/tex">\mathbf{R}_{0}(\mathbf{p})=\left[\begin{array}{c}\lambda p\\\bar{\lambda}\bar{p}\end{array}\right]+\sum_{j=1}^{M}\left[\begin{array}{c}\gamma_{j}p^{j+1}\bar{p}^{j}\\\bar{\gamma}_{j}p^{j}\bar{p}^{j+1}\end{array}\right],</script></p><p>Subsitution of <span class="MathJax_Preview"><img alt="$p=\rho e^{\mathrm{i}\theta}$" src="extract_backbone_eq00201628040979866949-Rescaled.png" style="width: 44.4px; height: auto;"/></span><script type="math/tex">p=\rho e^{\mathrm{i}\theta}</script> and <span class="MathJax_Preview"><img alt="$\bar{p}=\rho e^{-\mathrm{i}\theta}$" src="extract_backbone_eq13525975286259834256-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\bar{p}=\rho e^{-\mathrm{i}\theta}</script> to <span class="MathJax_Preview"><img alt="$\dot{\mathbf{p}}=\mathbf{R}_0(\mathbf{p})$" src="extract_backbone_eq14155904027307841531-Rescaled.png" style="width: 61.199999999999996px; height: auto;"/></span><script type="math/tex">\dot{\mathbf{p}}=\mathbf{R}_0(\mathbf{p})</script> yields</p><p><span class="MathJax_Preview"><img alt="$$\dot{\rho}=a(\rho), \dot{\theta}=b(\rho)$$" src="extract_backbone_eq18162186502425618118-Rescaled.png" style="width: 100.8px; height: auto;"/></span><script type="math/tex">\dot{\rho}=a(\rho), \dot{\theta}=b(\rho)</script></p><p>where</p><p><span class="MathJax_Preview"><img alt="$$a(\rho)=\sum_{j=1}^{M}\Re(\gamma_{j})\rho^{2j+1}+\rho\Re(\lambda),$$" src="extract_backbone_eq02659283612994844431-Rescaled.png" style="width: 176.4px; height: auto;"/></span><script type="math/tex">a(\rho)=\sum_{j=1}^{M}\Re(\gamma_{j})\rho^{2j+1}+\rho\Re(\lambda),</script></p><p><span class="MathJax_Preview"><img alt="$$b(\rho)=\sum_{j=1}^{M}\Im(\gamma_{j})\rho^{2j+1}+\rho\Im(\lambda).$$" src="extract_backbone_eq09784876221943622765-Rescaled.png" style="width: 174.0px; height: auto;"/></span><script type="math/tex">b(\rho)=\sum_{j=1}^{M}\Im(\gamma_{j})\rho^{2j+1}+\rho\Im(\lambda).</script></p><p>It follows that the <i>backbone curves</i> in polar coordinates is given by <span class="MathJax_Preview"><img alt="$\Omega=\frac{b(\rho)}{\rho}$" src="extract_backbone_eq17927103544304565835-Rescaled.png" style="width: 44.4px; height: auto;"/></span><script type="math/tex">\Omega=\frac{b(\rho)}{\rho}</script>.</p><p>The range of rho is determined by quadratic approximation of backbone curve if varargin is empty. Otherwise, it is specified via varargin.</p><pre class="codeinput">f1 = figure(<span class="string">'Name'</span>,<span class="string">'Norm'</span>);
<span class="keyword">if</span> isnumeric(obj.FRCOptions.outdof)
    f2 = figure(<span class="string">'Name'</span>,[<span class="string">'Amplitude at DOFs '</span> num2str(obj.FRCOptions.outdof(:)')]);
<span class="keyword">else</span>
    f2 = figure(<span class="string">'Name'</span>,<span class="string">'Amplitude at DOFs'</span>);
<span class="keyword">end</span>
figs = [f1, f2];
colors = get(0,<span class="string">'defaultaxescolororder'</span>);


assert(numel(modes)==2,<span class="string">'The analytic backbone computation can only be performed for a two-dimensional SSM/LSM'</span>)
<span class="comment">% get options</span>
[nt, nRho, nOmega, rhoScale, outdof, saveIC]  = <span class="keyword">...</span>
    deal(obj.FRCOptions.nt, obj.FRCOptions.nRho, <span class="keyword">...</span>
    obj.FRCOptions.nPar, obj.FRCOptions.rhoScale, <span class="keyword">...</span>
    obj.FRCOptions.outdof, obj.FRCOptions.saveIC);
        </pre><h2 id="3">Setup</h2><pre class="codeinput">startBB = tic;
obj.<a href="../../../../Library/Manifold/choose_E.html">choose_E</a>(modes);
lambda = obj.E.spectrum(1);

<span class="comment">% some checks</span>
assert(~isreal(lambda),<span class="string">'The eigenvalues associated to the modal subspace must be complex for analytic backbone computation'</span>)
omega0 = abs(imag(lambda));
assert(prod([omega0-omegaRange(1),omega0-omegaRange(end)])&lt;0,<span class="string">'The supplied omegaRange must contain the natural frequency associated to the modes'</span>)
        </pre><h2 id="4">Loop over orders</h2><pre class="codeinput">norders = numel(order);
<span class="keyword">for</span> k=1:norders
        </pre><h2 id="5">Compute autonomous SSM coefficients</h2><pre class="codeinput">    [W0,R0] = obj.<a href="../../../../Library/Manifold/compute_whisker.html">compute_whisker</a>(order(k));
    gamma = <a href="../../../../Library/Features/frc/compute_gamma.html">compute_gamma</a>(R0);
        </pre><h2 id="6">Compute backbone</h2><pre class="codeinput">    <span class="keyword">if</span> numel(varargin)==0
        rho = compute_rho_grid(omegaRange,nOmega,rhoScale,gamma,lambda,nRho);
    <span class="keyword">else</span>
        rhomax = varargin{1};
        rho = linspace(0.001*rhomax,rhomax,nRho);
    <span class="keyword">end</span>
    [~,b] = <a href="../../../../Library/Features/frc/frc_ab.html">frc_ab</a>(rho, 0, gamma, lambda);
    omega = b./rho;
    idx = [find(omega&lt;omegaRange(1)) find(omega&gt;omegaRange(2))];
    rho(idx) = []; omega(idx) = [];
        </pre><h2 id="7">Backbone curves in Physical Coordinates</h2><pre class="codeinput">    stability = true(size(rho)); psi = zeros(size(rho)); epsilon = 0;
    BB = <a href="../../../../Library/SSM/private/compute_output_polar2D.html">compute_output_polar2D</a>(rho,psi,stability,epsilon,omega,W0,[],1,nt, saveIC, outdof);
        </pre><h2 id="8">Plotting</h2><pre class="codeinput">    <a href="../../../../Library/Features/misc/plot_FRC.html">plot_FRC</a>(BB,outdof,order(k),<span class="string">'freq'</span>,<span class="string">'lines'</span>,figs,colors(k,:));
        </pre><pre class="codeinput"><span class="keyword">end</span>
totalComputationTime = toc(startBB);
disp([<span class="string">'Total time spent on backbone curve computation = '</span> datestr(datenum(0,0,0,0,0,totalComputationTime),<span class="string">'HH:MM:SS'</span>)])
        </pre><pre class="codeinput"><span class="keyword">end</span>
        </pre><h2 id="11">Compute grid</h2><pre class="codeinput"><span class="keyword">function</span> rho = compute_rho_grid(omegaRange,nOmega,rhoScale,gamma,lambda,nRho)
        </pre><pre class="codeinput">omega = linspace(omegaRange(1),omegaRange(end), nOmega);
        </pre><p><b>Explicit quadratic approximation of the backbone curve</b></p><p><span class="MathJax_Preview"><img alt="$$\rho_{backbone} = \sqrt{\frac{\Omega-\Im(\lambda)}{\Im(\gamma_1)}}$$" src="extract_backbone_eq08481158541239770140-Rescaled.png" style="width: 132.0px; height: auto;"/></span><script type="math/tex">\rho_{backbone} = \sqrt{\frac{\Omega-\Im(\lambda)}{\Im(\gamma_1)}}</script></p><pre class="codeinput">rho_bb = real(sqrt((omega - imag(lambda))/imag(gamma(1))));
rhomax = rhoScale * max(rho_bb);
rho = (rhomax/nRho) * (1:nRho);
        </pre><pre class="codeinput"><span class="keyword">end</span>
        </pre><p class="footer"><br/><a href="https://www.mathworks.com/products/matlab/">Published with MATLABÂ® R2023a</a><br/></p></div><!--
            ##### SOURCE BEGIN #####
            %% EXTRACT_BACKBONE
%
%%
function BB = extract_backbone(obj, modes, omegaRange, order, varargin)
%% Extract backbone
%
% This function extracts the *Backbone Curves in polar coordinates.* For two-dimensional
% SSMs, we use the normal form of paramaterization, where we choose the following
% form of autonomous reduced dynamics as
%
% $$\mathbf{R}_{0}(\mathbf{p})=\left[\begin{array}{c}\lambda p\\\bar{\lambda}\bar{p}\end{array}\right]+\sum_{j=1}^{M}\left[\begin{array}{c}\gamma_{j}p^{j+1}\bar{p}^{j}\\\bar{\gamma}_{j}p^{j}\bar{p}^{j+1}\end{array}\right],$$
%
% Subsitution of $p=\rho e^{\mathrm{i}\theta}$ and $\bar{p}=\rho e^{-\mathrm{i}\theta}$
% to $\dot{\mathbf{p}}=\mathbf{R}_0(\mathbf{p})$ yields
%
% $$\dot{\rho}=a(\rho), \dot{\theta}=b(\rho)$$
%
% where
%
% $$a(\rho)=\sum_{j=1}^{M}\Re(\gamma_{j})\rho^{2j+1}+\rho\Re(\lambda),$$
%
% $$b(\rho)=\sum_{j=1}^{M}\Im(\gamma_{j})\rho^{2j+1}+\rho\Im(\lambda).$$
%
% It follows that the _backbone curves_ in polar coordinates is given by $\Omega=\frac{b(\rho)}{\rho}$.
%
% The range of rho is determined by quadratic approximation of backbone
% curve if varargin is empty. Otherwise, it is specified via varargin.
%

f1 = figure('Name','Norm');
if isnumeric(obj.FRCOptions.outdof)
    f2 = figure('Name',['Amplitude at DOFs ' num2str(obj.FRCOptions.outdof(:)')]);
else
    f2 = figure('Name','Amplitude at DOFs');
end
figs = [f1, f2];
colors = get(0,'defaultaxescolororder');


assert(numel(modes)==2,'The analytic backbone computation can only be performed for a two-dimensional SSM/LSM')
% get options
[nt, nRho, nOmega, rhoScale, outdof, saveIC]  = ...
    deal(obj.FRCOptions.nt, obj.FRCOptions.nRho, ...
    obj.FRCOptions.nPar, obj.FRCOptions.rhoScale, ...
    obj.FRCOptions.outdof, obj.FRCOptions.saveIC);

%% Setup
startBB = tic;
obj.<a href="../../../../Library/Manifold/choose_E.html">choose_E</a>(modes);
lambda = obj.E.spectrum(1);

% some checks
assert(~isreal(lambda),'The eigenvalues associated to the modal subspace must be complex for analytic backbone computation')
omega0 = abs(imag(lambda));
assert(prod([omega0-omegaRange(1),omega0-omegaRange(end)])<0,'The supplied omegaRange must contain the natural frequency associated to the modes')

%% Loop over orders
norders = numel(order);
for k=1:norders
    %% Compute autonomous SSM coefficients
    %
    [W0,R0] = obj.<a href="../../../../Library/Manifold/compute_whisker.html">compute_whisker</a>(order(k));
    gamma = <a href="../../../../Library/Features/frc/compute_gamma.html">compute_gamma</a>(R0);

    %% Compute backbone
    %
    if numel(varargin)==0
        rho = compute_rho_grid(omegaRange,nOmega,rhoScale,gamma,lambda,nRho);
    else
        rhomax = varargin{1};
        rho = linspace(0.001*rhomax,rhomax,nRho);
    end
    [~,b] = <a href="../../../../Library/Features/frc/frc_ab.html">frc_ab</a>(rho, 0, gamma, lambda);
    omega = b./rho;
    idx = [find(omega<omegaRange(1)) find(omega>omegaRange(2))];
    rho(idx) = []; omega(idx) = [];

    %% Backbone curves in Physical Coordinates
    %
    stability = true(size(rho)); psi = zeros(size(rho)); epsilon = 0;
    BB = <a href="../../../../Library/SSM/private/compute_output_polar2D.html">compute_output_polar2D</a>(rho,psi,stability,epsilon,omega,W0,[],1,nt, saveIC, outdof);

    %% Plotting
    <a href="../../../../Library/Features/misc/plot_FRC.html">plot_FRC</a>(BB,outdof,order(k),'freq','lines',figs,colors(k,:));
end
totalComputationTime = toc(startBB);
disp(['Total time spent on backbone curve computation = ' datestr(datenum(0,0,0,0,0,totalComputationTime),'HH:MM:SS')])
end

%% Compute grid
%

function rho = compute_rho_grid(omegaRange,nOmega,rhoScale,gamma,lambda,nRho)
omega = linspace(omegaRange(1),omegaRange(end), nOmega);
%%
% *Explicit quadratic approximation of the backbone curve*
%
% $$\rho_{backbone} = \sqrt{\frac{\Omega-\Im(\lambda)}{\Im(\gamma_1)}}$$
rho_bb = real(sqrt((omega - imag(lambda))/imag(gamma(1))));
rhomax = rhoScale * max(rho_bb);
rho = (rhomax/nRho) * (1:nRho);
end
            ##### SOURCE END #####
        --></body></html></body></html>