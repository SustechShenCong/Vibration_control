
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><body><div class="banner"><a href="../../../../index.html"><img alt="Logo" class="logo" src="../../../../logo.png" style="float:right" width="200"/></a></div><html><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--

                    This HTML was auto-generated from MATLAB code.
                    To make changes, update the MATLAB code and republish this document.
                --><title>EXTRACT_FRC</title><meta content="MATLAB 9.14" name="generator"/><link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/><meta content="2023-09-09" name="DC.date"/><meta content="extract_FRC.m" name="DC.source"/><style type="text/css">
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

            html { min-height:100%; margin-bottom:1px; }
            html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
            html body td { vertical-align:top; text-align:left; }

            h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
            h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
            h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

            a { color:#005fce; text-decoration:none; }
            a:hover { color:#005fce; text-decoration:underline; }
            a:visited { color:#004aa0; text-decoration:none; }

            p { padding:0px; margin:0px 0px 20px; }
            img { padding:0px; margin:0px 0px 20px; border:none; }
            p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

            ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
            ul li { padding:0px; margin:0px 0px 7px 0px; }
            ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
            ul li ol li { list-style:decimal; }
            ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
            ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
            ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
            ol li ol li { list-style-type:lower-alpha; }
            ol li ul { padding-top:7px; }
            ol li ul li { list-style:square; }

            .content { font-size:1.2em; line-height:140%; padding: 20px; }

            pre, code { font-size:12px; }
            tt { font-size: 1.2em; }
            pre { margin:0px 0px 20px; }
            pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
            pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
            pre.error { color:red; }

            @media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

            span.keyword { color:#0000FF }
            span.comment { color:#228B22 }
            span.string { color:#A020F0 }
            span.untermstring { color:#B20000 }
            span.syscmd { color:#B28C00 }
            span.typesection { color:#A0522D }

            .footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
            .footer p { margin:0px; }
            .footer a { color:#878787; }
            .footer a:hover { color:#878787; text-decoration:underline; }
            .footer a:visited { color:#878787; }

            table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
            table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

            .center {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 50%;
              }



        </style></head><body><div class="content"><h1>EXTRACT_FRC</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Extract Forced Response Curve</a></li><li><a href="#5">FRC computation within the subinterval</a></li><li><a href="#7">Plot FRC in physical coordinates</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> FRC = extract_FRC(obj, parName, parRange, ORDER)
        </pre><h2 id="2">Extract Forced Response Curve</h2><p>This function extracts the forced response curve (FRC) for systems that may have internal resonances. The FRC computation is based on SSM computation. An appropriate SSM is constructed based on the resonant spectrum of system. The FRC is computed for the reduced system either by level-set technique or continuation method. The obtained FRC is finally mapped back to physical coordinates. By default, level-set method is used for 2D, underdamped SSMs. In any case, the continuation method is employed for higher dimensional SSMs.</p><p>FRC = EXTRACT_FRC(OBJ, PARNAME, PARRANGE, ORDER)</p><div><ul><li><tt>parName</tt>:  'amp'/'freq' continuation parameter. If parName='amp', FRC is           obtained with respect to forcing amplitude epsilon.           Specifically, SSM is constructed with assumption that Omega is           equal to obj.System.Omega. It follows that the constructed SSM           could have dimension higher than two. Then FRC is obtained by           level set method or parameter continuation in epsilon.           If parName='freq', FRC is obtained with respect to forcing           excitation frequency. In this case, SSM is constructed based on           the info of parRange. The range of frequency is divided into           some subintervals with a single natural frequency is included           in each subinterval, and the center point of two adjacent           natural frequencies defines the boundary point of two           consecutive subintervals. Within each subinterval, appropriate           SSM is constructed and then FRC is obtained.</li></ul></div><div><ul><li><tt>parRange</tt>: continuation domain of parameter</li></ul></div><div><ul><li><tt>order</tt>:    order of SSM expansion to be used for FRC computation</li></ul></div><div><ul><li><tt>FRC</tt>:      FRC data struct</li></ul></div><p>See also: FRC_LEVEL_SET, FRC_CONT_EP, FRC_CONT_PO</p><pre class="codeinput">f1 = figure(<span class="string">'Name'</span>,<span class="string">'Norm'</span>);
<span class="keyword">if</span> isnumeric(obj.FRCOptions.outdof)
    f2 = figure(<span class="string">'Name'</span>,[<span class="string">'Amplitude at DOFs '</span> num2str(obj.FRCOptions.outdof(:)')]);
<span class="keyword">else</span>
    f2 = figure(<span class="string">'Name'</span>,<span class="string">'Amplitude at DOFs'</span>);
<span class="keyword">end</span>
figs = [f1, f2];
colors = get(0,<span class="string">'defaultaxescolororder'</span>);
totalComputationTime = zeros(size(ORDER));

<span class="keyword">for</span> j = 1:numel(ORDER)
        </pre><pre class="codeinput">    order = ORDER(j);
    startFRC = tic;
    <span class="keyword">if</span> isempty(obj.System.spectrum)
        [~,~,~] = obj.System.<a href="../../../../Library/DynamicalSystem/linear_spectral_analysis.html">linear_spectral_analysis</a>();
    <span class="keyword">end</span>
    lambda  = obj.System.spectrum.Lambda;
    assert(~isreal(lambda),<span class="string">'One or more eigenvalues must be underdamped for FRC computation using SSMs'</span>)

    <span class="comment">% detect resonant eigenvalues in the parameter range</span>
    <span class="keyword">switch</span> lower(parName)
        <span class="keyword">case</span> <span class="string">'freq'</span>
            <span class="keyword">if</span> ~isempty(obj.System.fext)
                assert(~isempty(obj.System.fext.epsilon), <span class="string">'The epsilon field is empty in the dynamical system external forcing'</span>);
            <span class="keyword">else</span>
                assert(~isempty(obj.System.Fext.epsilon), <span class="string">'The epsilon field is empty in the dynamical system external forcing'</span>);
            <span class="keyword">end</span>
            [resLambda,resFreq] = find_eigs_in_freq_range(parRange,lambda,obj.FRCOptions.resType);

            <span class="comment">% obtain subintervals around each resonant eigenvalue</span>
            [parNodes, nSubint] = subdivide_freq_range(parRange, resFreq);
        <span class="keyword">case</span> <span class="string">'amp'</span>
            assert(~isempty(obj.System.Omega), <span class="string">'The Omega field is empty in the dynamical system'</span>);
            <span class="comment">% find eigenvalue nearest to forcing frequency</span>
            [~,idx] = min(abs(lambda - 1i*obj.System.Omega));
            resLambda = lambda(idx);
            <span class="comment">% setup for loop</span>
            parNodes = [parRange(1) parRange(end)];
            nSubint = 1;
    <span class="keyword">end</span>

    FRC = cell(nSubint,1);
    <span class="keyword">for</span> i=1:nSubint
        </pre><pre class="codeinput">        <span class="comment">% tune subinterval</span>
        parSubRange = parNodes(i:i+1)';
        parSubRange = tune_parameter_range(parSubRange, obj.FRCOptions.frac, i, nSubint);

        <span class="comment">% detect modes resonant with resLambda(i)</span>
        [resModes,mFreqs] = <a href="../../../../Library/SSM/private/detect_resonant_modes.html">detect_resonant_modes</a>(resLambda(i),lambda, obj.Options.IRtol);
        </pre><h2 id="5">FRC computation within the subinterval</h2><pre class="codeinput">        disp(<span class="string">'*****************************************'</span>);
        disp([<span class="string">'Calculating FRC using SSM with master subspace: ['</span> num2str(resModes(:).') <span class="string">']'</span>]);

        <span class="keyword">switch</span> obj.FRCOptions.method
            <span class="keyword">case</span> <span class="string">'level set'</span>
                FRC{i} = obj.<a href="../../../../Library/SSM/FRC_level_set.html">FRC_level_set</a>(resModes,order,parName,parSubRange);
                plotStyle = <span class="string">'circles'</span>;
            <span class="keyword">case</span> <span class="string">'continuation ep'</span>
                <span class="comment">% call continuation based method</span>
                mFreqs = mFreqs(1:2:end)';
                runid  = [<span class="string">'freqSubint'</span>,num2str(i)];
                <span class="keyword">if</span> j&gt;1 <span class="comment">% take lowest order solution as initial guess</span>
                    sol_jminus1 = ep_read_solution(<span class="string">''</span>, [runid,<span class="string">'.ep'</span>], 1);
                    obj.FRCOptions.p0 = sol_jminus1.p;
                    obj.FRCOptions.z0 = sol_jminus1.x;
                <span class="keyword">end</span>
                FRC{i}   = obj.<a href="../../../../Library/SSM/FRC_cont_ep.html">FRC_cont_ep</a>(runid,resModes,order,mFreqs,parName,parSubRange);
                plotStyle = <span class="string">'lines'</span>;
            <span class="keyword">case</span> <span class="string">'continuation po'</span>
                runid  = [<span class="string">'freqSubint'</span>,num2str(i)];
                FRCi = obj.<a href="../../../../Library/SSM/FRC_cont_po.html">FRC_cont_po</a>(runid,resModes,order,parSubRange);
                FRC{i}  = cat(2,FRCi{:});
                plotStyle = <span class="string">'circles'</span>;
        <span class="keyword">end</span>
        </pre><pre class="codeinput">    <span class="keyword">end</span>
    <span class="comment">% concatenate cell contents as struct arrays</span>
    FRC = cat(1,FRC{:});
    totalComputationTime(j) = toc(startFRC);
        </pre><h2 id="7">Plot FRC in physical coordinates</h2><pre class="codeinput">    <a href="../../../../Library/Features/misc/plot_FRC.html">plot_FRC</a>(FRC,obj.FRCOptions.outdof,order,parName,plotStyle, figs, colors(j,:))
        </pre><pre class="codeinput"><span class="keyword">end</span>


<span class="keyword">for</span> j = 1:numel(ORDER)
    disp([<span class="string">'Total time spent on FRC computation upto O('</span> num2str(ORDER(j)) <span class="string">') = '</span> datestr(datenum(0,0,0,0,0,totalComputationTime(j)),<span class="string">'HH:MM:SS'</span>)])
<span class="keyword">end</span>
        </pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> parRange = tune_parameter_range(parRange, frac, i, nSubint)
<span class="comment">% amplify the parameter subinterval except on the first and the last nodes.</span>
<span class="keyword">if</span> i&gt;1
    parRange(1) = frac(1)*parRange(1);
<span class="keyword">end</span>
<span class="keyword">if</span> i&lt;nSubint
    parRange(2) = frac(2)*parRange(2);
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [resLambda, resFreq] = find_eigs_in_freq_range(Omega,lambda,resType)

<span class="keyword">switch</span> resType
    <span class="keyword">case</span> <span class="string">'2:1'</span>  <span class="comment">% Case of subharmonic resonance</span>

    natFreq = imag(lambda);
    resFreqID = intersect(find(2*natFreq&gt;Omega(1)), find(2*natFreq&lt;Omega(end)));
    resFreq = natFreq(resFreqID);
    resLambda = lambda(resFreqID);

    assert(~isempty(resFreq),<span class="string">'Input frequency range should include dual multiple of natural frequency'</span>);

    <span class="keyword">case</span> <span class="string">'1:1'</span>

    natFreq = imag(lambda);
    resFreqID = intersect(find(natFreq&gt;Omega(1)), find(natFreq&lt;Omega(end)));
    resFreq = natFreq(resFreqID);
    resLambda = lambda(resFreqID);
    assert(~isempty(resFreq),<span class="string">'Input frequency range should include at least one natural frequency'</span>);
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> [freqNodes, nSubint] = subdivide_freq_range(parRange,resFreq)
nSubint = numel(resFreq);
freqNodes = 0.5*(resFreq(1:end-1)+resFreq(2:end)); <span class="comment">% center points of two adjacent resonant modes</span>
freqNodes = [parRange(1); freqNodes; parRange(2)];
<span class="keyword">end</span>
        </pre><p class="footer"><br/><a href="https://www.mathworks.com/products/matlab/">Published with MATLABÂ® R2023a</a><br/></p></div><!--
            ##### SOURCE BEGIN #####
            %% EXTRACT_FRC
%
%%
function FRC = extract_FRC(obj, parName, parRange, ORDER)
%% Extract Forced Response Curve
% This function extracts the forced response curve (FRC) for
% systems that may have internal resonances. The FRC computation is based
% on SSM computation. An appropriate SSM is constructed based on the
% resonant spectrum of system. The FRC is computed for the reduced system
% either by level-set technique or continuation method. The
% obtained FRC is finally mapped back to physical coordinates. By default,
% level-set method is used for 2D, underdamped SSMs. In any case,
% the continuation method is employed for higher dimensional SSMs.
%
% FRC = EXTRACT_FRC(OBJ, PARNAME, PARRANGE, ORDER)
%
% * |parName|:  'amp'/'freq' continuation parameter. If parName='amp', FRC is
%           obtained with respect to forcing amplitude epsilon.
%           Specifically, SSM is constructed with assumption that Omega is
%           equal to obj.System.Omega. It follows that the constructed SSM
%           could have dimension higher than two. Then FRC is obtained by
%           level set method or parameter continuation in epsilon.
%           If parName='freq', FRC is obtained with respect to forcing
%           excitation frequency. In this case, SSM is constructed based on
%           the info of parRange. The range of frequency is divided into
%           some subintervals with a single natural frequency is included
%           in each subinterval, and the center point of two adjacent
%           natural frequencies defines the boundary point of two
%           consecutive subintervals. Within each subinterval, appropriate
%           SSM is constructed and then FRC is obtained.
% 
% * |parRange|: continuation domain of parameter
% 
% * |order|:    order of SSM expansion to be used for FRC computation
%
% * |FRC|:      FRC data struct
%
% See also: FRC_LEVEL_SET, FRC_CONT_EP, FRC_CONT_PO 

f1 = figure('Name','Norm');
if isnumeric(obj.FRCOptions.outdof)
    f2 = figure('Name',['Amplitude at DOFs ' num2str(obj.FRCOptions.outdof(:)')]);
else
    f2 = figure('Name','Amplitude at DOFs');
end
figs = [f1, f2];
colors = get(0,'defaultaxescolororder');
totalComputationTime = zeros(size(ORDER));

for j = 1:numel(ORDER)
    order = ORDER(j);
    startFRC = tic;
    if isempty(obj.System.spectrum)
        [~,~,~] = obj.System.<a href="../../../../Library/DynamicalSystem/linear_spectral_analysis.html">linear_spectral_analysis</a>();
    end
    lambda  = obj.System.spectrum.Lambda;
    assert(~isreal(lambda),'One or more eigenvalues must be underdamped for FRC computation using SSMs')
    
    % detect resonant eigenvalues in the parameter range
    switch lower(parName)
        case 'freq'
            if ~isempty(obj.System.fext)
                assert(~isempty(obj.System.fext.epsilon), 'The epsilon field is empty in the dynamical system external forcing');
            else
                assert(~isempty(obj.System.Fext.epsilon), 'The epsilon field is empty in the dynamical system external forcing');
            end
            [resLambda,resFreq] = find_eigs_in_freq_range(parRange,lambda,obj.FRCOptions.resType);

            % obtain subintervals around each resonant eigenvalue
            [parNodes, nSubint] = subdivide_freq_range(parRange, resFreq);
        case 'amp'
            assert(~isempty(obj.System.Omega), 'The Omega field is empty in the dynamical system');
            % find eigenvalue nearest to forcing frequency
            [~,idx] = min(abs(lambda - 1i*obj.System.Omega));
            resLambda = lambda(idx);
            % setup for loop
            parNodes = [parRange(1) parRange(end)];
            nSubint = 1;
    end
    
    FRC = cell(nSubint,1);
    for i=1:nSubint
        % tune subinterval
        parSubRange = parNodes(i:i+1)';
        parSubRange = tune_parameter_range(parSubRange, obj.FRCOptions.frac, i, nSubint);
        
        % detect modes resonant with resLambda(i)
        [resModes,mFreqs] = <a href="../../../../Library/SSM/private/detect_resonant_modes.html">detect_resonant_modes</a>(resLambda(i),lambda, obj.Options.IRtol);
        
        %% FRC computation within the subinterval
        disp('*****************************************');
        disp(['Calculating FRC using SSM with master subspace: [' num2str(resModes(:).') ']']);
        
        switch obj.FRCOptions.method
            case 'level set'
                FRC{i} = obj.<a href="../../../../Library/SSM/FRC_level_set.html">FRC_level_set</a>(resModes,order,parName,parSubRange);
                plotStyle = 'circles';
            case 'continuation ep'
                % call continuation based method
                mFreqs = mFreqs(1:2:end)';
                runid  = ['freqSubint',num2str(i)];
                if j>1 % take lowest order solution as initial guess
                    sol_jminus1 = ep_read_solution('', [runid,'.ep'], 1);
                    obj.FRCOptions.p0 = sol_jminus1.p;
                    obj.FRCOptions.z0 = sol_jminus1.x;
                end                
                FRC{i}   = obj.<a href="../../../../Library/SSM/FRC_cont_ep.html">FRC_cont_ep</a>(runid,resModes,order,mFreqs,parName,parSubRange);
                plotStyle = 'lines';
            case 'continuation po'
                runid  = ['freqSubint',num2str(i)];
                FRCi = obj.<a href="../../../../Library/SSM/FRC_cont_po.html">FRC_cont_po</a>(runid,resModes,order,parSubRange);
                FRC{i}  = cat(2,FRCi{:});
                plotStyle = 'circles';
        end
    end
    % concatenate cell contents as struct arrays
    FRC = cat(1,FRC{:});
    totalComputationTime(j) = toc(startFRC);
    
    %% Plot FRC in physical coordinates
    <a href="../../../../Library/Features/misc/plot_FRC.html">plot_FRC</a>(FRC,obj.FRCOptions.outdof,order,parName,plotStyle, figs, colors(j,:))
    
end


for j = 1:numel(ORDER)    
    disp(['Total time spent on FRC computation upto O(' num2str(ORDER(j)) ') = ' datestr(datenum(0,0,0,0,0,totalComputationTime(j)),'HH:MM:SS')])
end

end

function parRange = tune_parameter_range(parRange, frac, i, nSubint)
% amplify the parameter subinterval except on the first and the last nodes.
if i>1
    parRange(1) = frac(1)*parRange(1);
end
if i<nSubint
    parRange(2) = frac(2)*parRange(2);
end
end

function [resLambda, resFreq] = find_eigs_in_freq_range(Omega,lambda,resType)

switch resType
    case '2:1'  % Case of subharmonic resonance

    natFreq = imag(lambda);
    resFreqID = intersect(find(2*natFreq>Omega(1)), find(2*natFreq<Omega(end)));
    resFreq = natFreq(resFreqID);
    resLambda = lambda(resFreqID);

    assert(~isempty(resFreq),'Input frequency range should include dual multiple of natural frequency'); 
    
    case '1:1'
        
    natFreq = imag(lambda);
    resFreqID = intersect(find(natFreq>Omega(1)), find(natFreq<Omega(end)));
    resFreq = natFreq(resFreqID);
    resLambda = lambda(resFreqID);
    assert(~isempty(resFreq),'Input frequency range should include at least one natural frequency'); 
end

end

function [freqNodes, nSubint] = subdivide_freq_range(parRange,resFreq)
nSubint = numel(resFreq);
freqNodes = 0.5*(resFreq(1:end-1)+resFreq(2:end)); % center points of two adjacent resonant modes
freqNodes = [parRange(1); freqNodes; parRange(2)];
end
            ##### SOURCE END #####
        --></body></html></body></html>