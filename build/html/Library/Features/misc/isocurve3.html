
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><body><div class="banner"><a href="../../../index.html"><img alt="Logo" class="logo" src="../../../logo.png" style="float:right" width="200"/></a></div><html><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--

                    This HTML was auto-generated from MATLAB code.
                    To make changes, update the MATLAB code and republish this document.
                --><title>Isocurve in 3 dimension</title><meta content="MATLAB 9.14" name="generator"/><link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/><meta content="2023-09-09" name="DC.date"/><meta content="isocurve3.m" name="DC.source"/><style type="text/css">
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

            html { min-height:100%; margin-bottom:1px; }
            html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
            html body td { vertical-align:top; text-align:left; }

            h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
            h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
            h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

            a { color:#005fce; text-decoration:none; }
            a:hover { color:#005fce; text-decoration:underline; }
            a:visited { color:#004aa0; text-decoration:none; }

            p { padding:0px; margin:0px 0px 20px; }
            img { padding:0px; margin:0px 0px 20px; border:none; }
            p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

            ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
            ul li { padding:0px; margin:0px 0px 7px 0px; }
            ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
            ul li ol li { list-style:decimal; }
            ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
            ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
            ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
            ol li ol li { list-style-type:lower-alpha; }
            ol li ul { padding-top:7px; }
            ol li ul li { list-style:square; }

            .content { font-size:1.2em; line-height:140%; padding: 20px; }

            pre, code { font-size:12px; }
            tt { font-size: 1.2em; }
            pre { margin:0px 0px 20px; }
            pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
            pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
            pre.error { color:red; }

            @media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

            span.keyword { color:#0000FF }
            span.comment { color:#228B22 }
            span.string { color:#A020F0 }
            span.untermstring { color:#B20000 }
            span.syscmd { color:#B28C00 }
            span.typesection { color:#A0522D }

            .footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
            .footer p { margin:0px; }
            .footer a { color:#878787; }
            .footer a:hover { color:#878787; text-decoration:underline; }
            .footer a:visited { color:#878787; }

            table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
            table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

            .center {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 50%;
              }



        </style></head><body><div class="content"><h1>Isocurve in 3 dimension</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">h = isocurve3</a></li><li><a href="#3">Compute first isosurface and faces crossing second isosurface</a></li><li><a href="#4">Restrict to vertices of crossing faces, renumber vertices</a></li><li><a href="#5">Alternating edge to vertex mapping</a></li><li><a href="#6">Face to alternating edge mapping</a></li><li><a href="#7">Alternating edge to face mapping</a></li><li><a href="#8">Build alternating edge-to-edge mapping</a></li><li><a href="#9">Compute crossings on alternating edges</a></li><li><a href="#10">Build adjacency matrix</a></li><li><a href="#11">Compute parts (connected components)</a></li><li><a href="#12">Part edge numbers (unsorted)</a></li><li><a href="#13">Sort edges in each part</a></li><li><a href="#14">Plot curves</a></li><li><a href="#15">Diagnostic plot for edge-face mappings</a></li><li><a href="#16">Auxiliary functions for diagnostic plot</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> h = isocurve3( X,Y,Z,V1,V2,isovalue1,isovalue2,varargin)
        </pre><h2 id="2">h = isocurve3</h2><p>Plot intersection curve between isosurfaces</p><div><ul><li>X,Y,Z,V1,isovalue1 and X,Y,Z,V2,isovalue2 are input data for isosurface</li></ul></div><p>Additional arguments are passed to plot3</p><div><ul><li>h - axes handle</li></ul></div><p>Copyright: Leif Persson, Mathematics department, Umeå University, March 2016</p><pre class="codeinput">diagnostic_mode = false;
        </pre><h2 id="3">Compute first isosurface and faces crossing second isosurface</h2><pre class="codeinput">h=isosurface(X,Y,Z,V1,isovalue1);
v=h.vertices; <span class="comment">% Vertex coordinates; v(i_v,:) are the x,y,z-coordinates of vertex i_v</span>
f2v=h.faces; <span class="comment">% Faces of isosurface 1; f(i_f,:) are the vertex numbers of face i_f</span>
V21 = interp3(X,Y,Z,V2,v(:,1),v(:,2),v(:,3)); <span class="comment">% Interpolated V2 values on vertices of isosurface 1</span>
s_f=V21(f2v)-isovalue2; <span class="comment">% Second isosurface sign on faces of first surface</span>
is_cf=(s_f(:,1).*s_f(:,2)&lt;=0)|(s_f(:,2).*s_f(:,3)&lt;=0)|(s_f(:,3).*s_f(:,1)&lt;0); <span class="comment">% boolean vector for crossing faces</span>
f2v=f2v(is_cf,:); <span class="comment">% Restrict to crossing faces</span>
n_v=size(v,1); <span class="comment">% Number of vertices</span>
n_f=size(f2v,1); <span class="comment">% Number of faces</span>
s_f = s_f(is_cf,:);
        </pre><h2 id="4">Restrict to vertices of crossing faces, renumber vertices</h2><pre class="codeinput">old_i_v = unique(f2v);
v = v(old_i_v, :);
V21 = V21(old_i_v);
n_new_v = length(old_i_v);
v2new_v=zeros(size(1,n_v));
v2new_v(old_i_v) = 1:n_new_v; <span class="comment">% Translation vector</span>
<span class="keyword">for</span> i_f=1:n_f,
    f2v(i_f,1)=v2new_v(f2v(i_f,1));
    f2v(i_f,2)=v2new_v(f2v(i_f,2));
    f2v(i_f,3)=v2new_v(f2v(i_f,3));
<span class="keyword">end</span>
n_v = size(v,1);
        </pre><h2 id="5">Alternating edge to vertex mapping</h2><pre class="codeinput">e2v = [];
<span class="keyword">for</span> i_f=1:n_f,
    <span class="keyword">if</span> s_f(i_f,1)*s_f(i_f,2)&lt;=0
        e2v = [ e2v; f2v(i_f,[1,2]) ];
    <span class="keyword">end</span>
    <span class="keyword">if</span> s_f(i_f,2)*s_f(i_f,3)&lt;=0
        e2v = [ e2v; f2v(i_f,[2,3]) ];
    <span class="keyword">end</span>
    <span class="keyword">if</span> s_f(i_f,3)*s_f(i_f,1)&lt;=0
        e2v = [ e2v; f2v(i_f,[3,1]) ];
    <span class="keyword">end</span>
<span class="keyword">end</span>
e2v = unique(sort(e2v,2),<span class="string">'rows'</span>);
n_e = size(e2v,1);
        </pre><h2 id="6">Face to alternating edge mapping</h2><pre class="codeinput">v2e = sparse([e2v(:,1);e2v(:,2)],[e2v(:,2);e2v(:,1)],[(1:n_e)'; (1:n_e)'],n_v,n_v);
f2e = zeros(n_f,2);
<span class="keyword">for</span> i_f=1:n_f,
    k=1;
    i_e = v2e(f2v(i_f,1),f2v(i_f,2));
    <span class="keyword">if</span> i_e &gt; 0,
        f2e(i_f, k) = i_e; k=k+1;
    <span class="keyword">end</span>
    i_e = v2e(f2v(i_f,2),f2v(i_f,3));
    <span class="keyword">if</span> i_e &gt; 0,
        f2e(i_f, k) = i_e; k=k+1;
    <span class="keyword">end</span>
    i_e = v2e(f2v(i_f,3),f2v(i_f,1));
    <span class="keyword">if</span> i_e &gt; 0,
        f2e(i_f, k) = i_e; k=k+1;
    <span class="keyword">end</span>
<span class="keyword">end</span>
        </pre><h2 id="7">Alternating edge to face mapping</h2><pre class="codeinput">e2f = zeros(n_e,2);
<span class="keyword">for</span> i_f=1:n_f,
    i_e = f2e(i_f,1);
    <span class="keyword">if</span> i_e&gt;0,
        <span class="keyword">if</span> e2f(i_e,1)==0,
            e2f(i_e,1)=i_f;
        <span class="keyword">elseif</span> e2f(i_e,2)==0
            e2f(i_e,2)=i_f;
        <span class="keyword">else</span>
            error(<span class="string">'Too many faces for edge'</span>);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    i_e=f2e(i_f,2);
    <span class="keyword">if</span> i_e&gt;0,
        <span class="keyword">if</span> e2f(i_e,1)==0,
            e2f(i_e,1)=i_f;
        <span class="keyword">elseif</span> e2f(i_e,2)==0
            e2f(i_e,2)=i_f;
        <span class="keyword">else</span>
            error(<span class="string">'Too many faces for edge'</span>);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
        </pre><h2 id="8">Build alternating edge-to-edge mapping</h2><pre class="codeinput">e2e = zeros(n_e,2);
<span class="keyword">for</span> i_e=1:n_e,
    j_f=e2f(i_e,:);
    j_f=j_f(j_f&gt;0); <span class="comment">% The faces neighboring edge i_e (may be one or two)</span>
    k_e=f2e(j_f,:); <span class="comment">% The edges of those faces</span>
    k_e=reshape(k_e,1,[]);
    k_e=k_e((k_e&gt;0)&amp;(k_e~=i_e)); <span class="comment">% The neighboring edges of i_e</span>
    e2e(i_e,1:length(k_e))=k_e;
<span class="keyword">end</span>
<span class="keyword">if</span> size(e2e,2)&gt;2,
    error(<span class="string">'Incompatible edge-to-edge mapping'</span>);
<span class="keyword">end</span>
        </pre><h2 id="9">Compute crossings on alternating edges</h2><pre class="codeinput">tmp=abs(V21(e2v)-isovalue2);
c = zeros(n_e,3);
c(:,1) = (v(e2v(:,1),1).*tmp(:,2)+v(e2v(:,2),1).*tmp(:,1))./(tmp(:,1)+tmp(:,2));
c(:,2) = (v(e2v(:,1),2).*tmp(:,2)+v(e2v(:,2),2).*tmp(:,1))./(tmp(:,1)+tmp(:,2));
c(:,3) = (v(e2v(:,1),3).*tmp(:,2)+v(e2v(:,2),3).*tmp(:,1))./(tmp(:,1)+tmp(:,2));
        </pre><h2 id="10">Build adjacency matrix</h2><pre class="codeinput">A = sparse(n_e,n_e);
<span class="keyword">for</span> i_e=1:n_e,
    tmp = e2e(i_e,:);
    A(i_e, tmp(tmp&gt;0))=1;
<span class="keyword">end</span>
<span class="keyword">if</span> any(diag(A)~=0) || any(any(A~=A')),
    error(<span class="string">'Incompatible adjacency matrix'</span>);
<span class="keyword">end</span>
        </pre><h2 id="11">Compute parts (connected components)</h2><pre class="codeinput">p = []; <span class="comment">% Boolean matrix; each row represents nodes of one component</span>
r = ones(1,n_e); <span class="comment">% Boolean vector for remaining nodes</span>
<span class="keyword">while</span> any(r&gt;0)
    x=zeros(1,n_e);
    i_e=find(r,1);
    x(i_e)=1; <span class="comment">% Start with first remaining edge</span>
    tmp=x*(A+speye(size(A)))'; <span class="comment">% Add nodes</span>
    tmp=(tmp&gt;0);
    <span class="keyword">while</span> any(tmp~=x)
        x=tmp;
        tmp=x*(A+speye(size(A)))';
        tmp=(tmp&gt;0);
    <span class="keyword">end</span>
    p=[p;x];
    r = ~any([p; p]&gt;0);
<span class="keyword">end</span>
p=(p&gt;0);
n_p = size(p,1); <span class="comment">% Number of parts (connected components)</span>
        </pre><h2 id="12">Part edge numbers (unsorted)</h2><pre class="codeinput">p2e = zeros(size(p));
<span class="keyword">for</span> i_p=1:n_p,
    tmp=1:n_e;
    tmp = tmp(p(i_p,:));
    p2e(i_p,1:length(tmp))=tmp;
<span class="keyword">end</span>
n_ep = zeros(1,n_p);
        </pre><h2 id="13">Sort edges in each part</h2><pre class="codeinput">sorted_p2e = zeros(size(p,1),size(p,2)+1); <span class="comment">% +1 needed for closed curves</span>
<span class="keyword">for</span> i_p=1:n_p,
    ep=p2e(i_p,:);
    ep=ep(ep&gt;0); <span class="comment">% Edge numbers in part</span>
    n_ep(i_p) = length(ep);
    is_open_curve = any(e2f(ep,1)&lt;=0 | e2f(ep,2)&lt;=0);
    <span class="keyword">if</span> is_open_curve
<span class="comment">%        fprintf('Part %d is open\n', i_p);</span>
        i_ep = find(e2f(ep,1)&lt;=0 | e2f(ep,2)&lt;=0);
        ep_start=ep(i_ep(1));
        ep_end  =ep(i_ep(2));
    <span class="keyword">else</span>                                   <span class="comment">% Closed curve</span>
<span class="comment">%       fprintf('Part %d is closed\n', i_p);</span>
        n_ep(i_p)=n_ep(i_p)+1;
        ep_start=ep(1);
        ep_end  =ep(1);
    <span class="keyword">end</span>
    sorted_ep = zeros(1,n_ep(i_p)+1); <span class="comment">% +1 needed if closed curve</span>
    is_remaining_ep = true(1,n_e); <span class="comment">% Boolean vector indicating remaining edges</span>
    sorted_ep(1) = ep_start;
    is_remaining_ep(ep_start)=false;
    <span class="keyword">for</span> i_ep=2:n_ep(i_p)-1,
        j_f = e2f(sorted_ep(i_ep-1),:);
        j_f = j_f(j_f&gt;0);
        k_e = f2e(j_f,:);
        k_e = reshape(k_e,1,[]);
        k_e = k_e.*double(is_remaining_ep(k_e));
        k_e = k_e(k_e&gt;0);
        <span class="keyword">if</span> numel(k_e)==0
            error(<span class="string">'Sorting problem...'</span>);
        <span class="keyword">end</span>
        sorted_ep(i_ep)=k_e(1);
        is_remaining_ep(k_e(1))=false;
    <span class="keyword">end</span>
    i_ep = n_ep(i_p);
    sorted_ep(i_ep) = ep_end;
    sorted_p2e(i_p,1:numel(sorted_ep))=sorted_ep;
<span class="keyword">end</span>
p2e=sorted_p2e;
        </pre><h2 id="14">Plot curves</h2><pre class="codeinput"><span class="keyword">for</span> i_p=1:n_p,
    plot3(c(p2e(i_p,1:n_ep(i_p)),1),c(p2e(i_p,1:n_ep(i_p)),2),c(p2e(i_p,1:n_ep(i_p)),3),varargin{:});
    hold <span class="string">on</span>;
<span class="keyword">end</span>
h = gca; <span class="comment">% Return handle to current axis</span>
        </pre><h2 id="15">Diagnostic plot for edge-face mappings</h2><pre class="codeinput"><span class="keyword">if</span> diagnostic_mode,
    f_list=containers.Map(<span class="string">'KeyType'</span>, <span class="string">'double'</span>, <span class="string">'ValueType'</span>, <span class="string">'double'</span>);
    figure;
    hold <span class="string">on</span>;
    view(3);
    i_f=1; f_list(i_f)=0; <span class="comment">% Store i_f in face list</span>
    plot_face(i_f, <span class="string">'LineWidth'</span>, 2, <span class="string">'Color'</span>, <span class="string">'blue'</span>,<span class="string">'LineStyle'</span>, <span class="string">':'</span>);
    i_e=f2e(i_f,:); <span class="comment">% Alternating edges of face i_f</span>
    plot_edge(i_e(1), <span class="string">'LineWidth'</span>, 2, <span class="string">'Color'</span>, <span class="string">'red'</span>);
    plot_edge(i_e(2), <span class="string">'LineWidth'</span>, 2, <span class="string">'Color'</span>, <span class="string">'red'</span>);
    j_f=unique(e2f(i_e,:));
    j_f=j_f(j_f&gt;0);
    <span class="keyword">while</span> any(~isKey(f_list, num2cell(j_f)))
        <span class="keyword">for</span> j=1:length(j_f),
            <span class="keyword">if</span> ~isKey(f_list, j_f(j)) <span class="keyword">break</span>; <span class="keyword">end</span>
        <span class="keyword">end</span>
        i_f=j_f(j); f_list(i_f)=0;
        plot_face(i_f, <span class="string">'LineWidth'</span>, 2, <span class="string">'Color'</span>, <span class="string">'blue'</span>,<span class="string">'LineStyle'</span>, <span class="string">':'</span>);
        i_e=f2e(i_f,:); <span class="comment">% Alternating edges of face i_f</span>
        plot_edge(i_e(1), <span class="string">'LineWidth'</span>, 2, <span class="string">'Color'</span>, <span class="string">'red'</span>);
        plot_edge(i_e(2), <span class="string">'LineWidth'</span>, 2, <span class="string">'Color'</span>, <span class="string">'red'</span>);
        j_f=unique(e2f(i_e,:));
        j_f=j_f(j_f&gt;0);
    <span class="keyword">end</span>
    <span class="keyword">for</span> i_p=1:n_p,
        plot3(c(p(i_p,:)',1),c(p(i_p,:)',2),c(p(i_p,:)',3),<span class="string">'o'</span>,<span class="string">'MarkerSize'</span>, 10, <span class="string">'MarkerFaceColor'</span>, <span class="string">'black'</span>);
    <span class="keyword">end</span>
    <span class="comment">%plot3(c(p(2,:)',1),c(p(2,:)',2),c(p(2,:)',3),'d','MarkerSize', 10, 'MarkerFaceColor', 'black');</span>
<span class="keyword">end</span>
        </pre><h2 id="16">Auxiliary functions for diagnostic plot</h2><pre class="codeinput">    <span class="keyword">function</span> plot_face(i_f,varargin)
        ii_e=f2e(i_f,:); <span class="comment">% Edges of face i_f</span>
        ii_v=e2v(ii_e,:); <span class="comment">% Vertex numbers of edges</span>
        ii_v=unique(ii_v); <span class="comment">% Unique vertex numbers</span>
        v_f=v(ii_v,:);
        line(v_f([1,2],1),v_f([1,2],2),v_f([1,2],3),varargin{:});
        line(v_f([2,3],1),v_f([2,3],2),v_f([2,3],3),varargin{:});
        line(v_f([3,1],1),v_f([3,1],2),v_f([3,1],3),varargin{:});
    <span class="keyword">end</span>
    <span class="keyword">function</span> plot_edge(i_e,varargin)
        ii_v=e2v(i_e,:); <span class="comment">% Vertex numbers of edge</span>
        v_f=v(ii_v,:);   <span class="comment">% Vertex coordinates</span>
        line(v_f([1,2],1),v_f([1,2],2),v_f([1,2],3),varargin{:});
        text(0.5*sum(v_f([1,2],1)), 0.5*sum(v_f([1,2],2)), 0.5*sum(v_f([1,2],3)), num2str(i_e));
    <span class="keyword">end</span>
        </pre><pre class="codeinput"><span class="keyword">end</span>
        </pre><p class="footer"><br/><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2023a</a><br/></p></div><!--
            ##### SOURCE BEGIN #####
            %% Isocurve in 3 dimension
%
%%
function h = isocurve3( X,Y,Z,V1,V2,isovalue1,isovalue2,varargin)
%% h = isocurve3
% 
% Plot intersection curve between isosurfaces
% 
% * X,Y,Z,V1,isovalue1 and X,Y,Z,V2,isovalue2 are input data for isosurface
% 
% Additional arguments are passed to plot3
% 
% * h - axes handle
% 
% Copyright: Leif Persson, Mathematics department, Umeå University, March 2016
%

diagnostic_mode = false;
%% Compute first isosurface and faces crossing second isosurface
h=isosurface(X,Y,Z,V1,isovalue1);
v=h.vertices; % Vertex coordinates; v(i_v,:) are the x,y,z-coordinates of vertex i_v
f2v=h.faces; % Faces of isosurface 1; f(i_f,:) are the vertex numbers of face i_f
V21 = interp3(X,Y,Z,V2,v(:,1),v(:,2),v(:,3)); % Interpolated V2 values on vertices of isosurface 1
s_f=V21(f2v)-isovalue2; % Second isosurface sign on faces of first surface
is_cf=(s_f(:,1).*s_f(:,2)<=0)|(s_f(:,2).*s_f(:,3)<=0)|(s_f(:,3).*s_f(:,1)<0); % boolean vector for crossing faces
f2v=f2v(is_cf,:); % Restrict to crossing faces
n_v=size(v,1); % Number of vertices
n_f=size(f2v,1); % Number of faces
s_f = s_f(is_cf,:);
%% Restrict to vertices of crossing faces, renumber vertices
old_i_v = unique(f2v);
v = v(old_i_v, :);
V21 = V21(old_i_v);
n_new_v = length(old_i_v);
v2new_v=zeros(size(1,n_v));
v2new_v(old_i_v) = 1:n_new_v; % Translation vector
for i_f=1:n_f,
    f2v(i_f,1)=v2new_v(f2v(i_f,1));
    f2v(i_f,2)=v2new_v(f2v(i_f,2));
    f2v(i_f,3)=v2new_v(f2v(i_f,3));
end
n_v = size(v,1);
%% Alternating edge to vertex mapping
e2v = [];
for i_f=1:n_f,
    if s_f(i_f,1)*s_f(i_f,2)<=0
        e2v = [ e2v; f2v(i_f,[1,2]) ];
    end
    if s_f(i_f,2)*s_f(i_f,3)<=0
        e2v = [ e2v; f2v(i_f,[2,3]) ];
    end
    if s_f(i_f,3)*s_f(i_f,1)<=0
        e2v = [ e2v; f2v(i_f,[3,1]) ];
    end
end
e2v = unique(sort(e2v,2),'rows');
n_e = size(e2v,1);
%% Face to alternating edge mapping
v2e = sparse([e2v(:,1);e2v(:,2)],[e2v(:,2);e2v(:,1)],[(1:n_e)'; (1:n_e)'],n_v,n_v);
f2e = zeros(n_f,2);
for i_f=1:n_f,
    k=1;
    i_e = v2e(f2v(i_f,1),f2v(i_f,2));
    if i_e > 0,
        f2e(i_f, k) = i_e; k=k+1;
    end
    i_e = v2e(f2v(i_f,2),f2v(i_f,3));
    if i_e > 0,
        f2e(i_f, k) = i_e; k=k+1;
    end
    i_e = v2e(f2v(i_f,3),f2v(i_f,1));
    if i_e > 0,
        f2e(i_f, k) = i_e; k=k+1;
    end
end
%% Alternating edge to face mapping
e2f = zeros(n_e,2);
for i_f=1:n_f,
    i_e = f2e(i_f,1);
    if i_e>0,
        if e2f(i_e,1)==0,
            e2f(i_e,1)=i_f;
        elseif e2f(i_e,2)==0
            e2f(i_e,2)=i_f;
        else
            error('Too many faces for edge');
        end
    end
    i_e=f2e(i_f,2);
    if i_e>0,
        if e2f(i_e,1)==0,
            e2f(i_e,1)=i_f;
        elseif e2f(i_e,2)==0
            e2f(i_e,2)=i_f;
        else
            error('Too many faces for edge');
        end
    end
end
%% Build alternating edge-to-edge mapping
e2e = zeros(n_e,2);
for i_e=1:n_e,
    j_f=e2f(i_e,:);
    j_f=j_f(j_f>0); % The faces neighboring edge i_e (may be one or two)
    k_e=f2e(j_f,:); % The edges of those faces
    k_e=reshape(k_e,1,[]);
    k_e=k_e((k_e>0)&(k_e~=i_e)); % The neighboring edges of i_e
    e2e(i_e,1:length(k_e))=k_e;
end
if size(e2e,2)>2,
    error('Incompatible edge-to-edge mapping');
end
%% Compute crossings on alternating edges
tmp=abs(V21(e2v)-isovalue2);
c = zeros(n_e,3);
c(:,1) = (v(e2v(:,1),1).*tmp(:,2)+v(e2v(:,2),1).*tmp(:,1))./(tmp(:,1)+tmp(:,2));
c(:,2) = (v(e2v(:,1),2).*tmp(:,2)+v(e2v(:,2),2).*tmp(:,1))./(tmp(:,1)+tmp(:,2));
c(:,3) = (v(e2v(:,1),3).*tmp(:,2)+v(e2v(:,2),3).*tmp(:,1))./(tmp(:,1)+tmp(:,2));
%% Build adjacency matrix
A = sparse(n_e,n_e);
for i_e=1:n_e,
    tmp = e2e(i_e,:);
    A(i_e, tmp(tmp>0))=1;
end
if any(diag(A)~=0) || any(any(A~=A')),
    error('Incompatible adjacency matrix');
end
%% Compute parts (connected components)
p = []; % Boolean matrix; each row represents nodes of one component
r = ones(1,n_e); % Boolean vector for remaining nodes
while any(r>0)
    x=zeros(1,n_e);
    i_e=find(r,1);
    x(i_e)=1; % Start with first remaining edge
    tmp=x*(A+speye(size(A)))'; % Add nodes
    tmp=(tmp>0);
    while any(tmp~=x)
        x=tmp;
        tmp=x*(A+speye(size(A)))';
        tmp=(tmp>0);
    end
    p=[p;x];
    r = ~any([p; p]>0);
end
p=(p>0);
n_p = size(p,1); % Number of parts (connected components)
%% Part edge numbers (unsorted)
p2e = zeros(size(p));
for i_p=1:n_p,
    tmp=1:n_e;
    tmp = tmp(p(i_p,:));
    p2e(i_p,1:length(tmp))=tmp;
end
n_ep = zeros(1,n_p);
%% Sort edges in each part
sorted_p2e = zeros(size(p,1),size(p,2)+1); % +1 needed for closed curves
for i_p=1:n_p,
    ep=p2e(i_p,:);
    ep=ep(ep>0); % Edge numbers in part
    n_ep(i_p) = length(ep);
    is_open_curve = any(e2f(ep,1)<=0 | e2f(ep,2)<=0);
    if is_open_curve
%        fprintf('Part %d is open\n', i_p);
        i_ep = find(e2f(ep,1)<=0 | e2f(ep,2)<=0);
        ep_start=ep(i_ep(1));
        ep_end  =ep(i_ep(2));
    else                                   % Closed curve
%       fprintf('Part %d is closed\n', i_p);
        n_ep(i_p)=n_ep(i_p)+1;
        ep_start=ep(1);
        ep_end  =ep(1);
    end
    sorted_ep = zeros(1,n_ep(i_p)+1); % +1 needed if closed curve
    is_remaining_ep = true(1,n_e); % Boolean vector indicating remaining edges
    sorted_ep(1) = ep_start;
    is_remaining_ep(ep_start)=false;
    for i_ep=2:n_ep(i_p)-1,
        j_f = e2f(sorted_ep(i_ep-1),:);
        j_f = j_f(j_f>0);
        k_e = f2e(j_f,:);
        k_e = reshape(k_e,1,[]);
        k_e = k_e.*double(is_remaining_ep(k_e));
        k_e = k_e(k_e>0);
        if numel(k_e)==0
            error('Sorting problem...');
        end
        sorted_ep(i_ep)=k_e(1);
        is_remaining_ep(k_e(1))=false;
    end
    i_ep = n_ep(i_p);
    sorted_ep(i_ep) = ep_end;
    sorted_p2e(i_p,1:numel(sorted_ep))=sorted_ep;
end
p2e=sorted_p2e;
%% Plot curves
for i_p=1:n_p,
    plot3(c(p2e(i_p,1:n_ep(i_p)),1),c(p2e(i_p,1:n_ep(i_p)),2),c(p2e(i_p,1:n_ep(i_p)),3),varargin{:});
    hold on;
end
h = gca; % Return handle to current axis
%% Diagnostic plot for edge-face mappings
if diagnostic_mode,
    f_list=containers.Map('KeyType', 'double', 'ValueType', 'double');
    figure;
    hold on;
    view(3);
    i_f=1; f_list(i_f)=0; % Store i_f in face list
    plot_face(i_f, 'LineWidth', 2, 'Color', 'blue','LineStyle', ':');
    i_e=f2e(i_f,:); % Alternating edges of face i_f
    plot_edge(i_e(1), 'LineWidth', 2, 'Color', 'red');
    plot_edge(i_e(2), 'LineWidth', 2, 'Color', 'red');
    j_f=unique(e2f(i_e,:));
    j_f=j_f(j_f>0);
    while any(~isKey(f_list, num2cell(j_f)))
        for j=1:length(j_f),
            if ~isKey(f_list, j_f(j)) break; end
        end
        i_f=j_f(j); f_list(i_f)=0;
        plot_face(i_f, 'LineWidth', 2, 'Color', 'blue','LineStyle', ':');
        i_e=f2e(i_f,:); % Alternating edges of face i_f
        plot_edge(i_e(1), 'LineWidth', 2, 'Color', 'red');
        plot_edge(i_e(2), 'LineWidth', 2, 'Color', 'red');
        j_f=unique(e2f(i_e,:));
        j_f=j_f(j_f>0);
    end
    for i_p=1:n_p,
        plot3(c(p(i_p,:)',1),c(p(i_p,:)',2),c(p(i_p,:)',3),'o','MarkerSize', 10, 'MarkerFaceColor', 'black');
    end
    %plot3(c(p(2,:)',1),c(p(2,:)',2),c(p(2,:)',3),'d','MarkerSize', 10, 'MarkerFaceColor', 'black');
end
%% Auxiliary functions for diagnostic plot
    function plot_face(i_f,varargin)
        ii_e=f2e(i_f,:); % Edges of face i_f
        ii_v=e2v(ii_e,:); % Vertex numbers of edges
        ii_v=unique(ii_v); % Unique vertex numbers
        v_f=v(ii_v,:);
        line(v_f([1,2],1),v_f([1,2],2),v_f([1,2],3),varargin{:});
        line(v_f([2,3],1),v_f([2,3],2),v_f([2,3],3),varargin{:});
        line(v_f([3,1],1),v_f([3,1],2),v_f([3,1],3),varargin{:});
    end
    function plot_edge(i_e,varargin)
        ii_v=e2v(i_e,:); % Vertex numbers of edge
        v_f=v(ii_v,:);   % Vertex coordinates
        line(v_f([1,2],1),v_f([1,2],2),v_f([1,2],3),varargin{:});
        text(0.5*sum(v_f([1,2],1)), 0.5*sum(v_f([1,2],2)), 0.5*sum(v_f([1,2],3)), num2str(i_e));
    end
end

            ##### SOURCE END #####
        --></body></html></body></html>