
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><body><div class="banner"><a href="../../../index.html"><img alt="Logo" class="logo" src="../../../logo.png" style="float:right" width="200"/></a></div><html><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--

                    This HTML was auto-generated from MATLAB code.
                    To make changes, update the MATLAB code and republish this document.
                --><title>Project onto SSM</title><meta content="MATLAB 9.14" name="generator"/><link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/><meta content="2023-09-09" name="DC.date"/><meta content="proj2SSM.m" name="DC.source"/><style type="text/css">
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

            html { min-height:100%; margin-bottom:1px; }
            html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
            html body td { vertical-align:top; text-align:left; }

            h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
            h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
            h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

            a { color:#005fce; text-decoration:none; }
            a:hover { color:#005fce; text-decoration:underline; }
            a:visited { color:#004aa0; text-decoration:none; }

            p { padding:0px; margin:0px 0px 20px; }
            img { padding:0px; margin:0px 0px 20px; border:none; }
            p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

            ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
            ul li { padding:0px; margin:0px 0px 7px 0px; }
            ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
            ul li ol li { list-style:decimal; }
            ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
            ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
            ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
            ol li ol li { list-style-type:lower-alpha; }
            ol li ul { padding-top:7px; }
            ol li ul li { list-style:square; }

            .content { font-size:1.2em; line-height:140%; padding: 20px; }

            pre, code { font-size:12px; }
            tt { font-size: 1.2em; }
            pre { margin:0px 0px 20px; }
            pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
            pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
            pre.error { color:red; }

            @media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

            span.keyword { color:#0000FF }
            span.comment { color:#228B22 }
            span.string { color:#A020F0 }
            span.untermstring { color:#B20000 }
            span.syscmd { color:#B28C00 }
            span.typesection { color:#A0522D }

            .footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
            .footer p { margin:0px; }
            .footer a { color:#878787; }
            .footer a:hover { color:#878787; text-decoration:underline; }
            .footer a:visited { color:#878787; }

            table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
            table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

            .center {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 50%;
              }



        </style></head><body><div class="content"><h1>Project onto SSM</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">PROJ2SSM</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> varargout = proj2SSM(z0,projMethod,varargin)
        </pre><h2 id="2">PROJ2SSM</h2><p>This function returns the projection of point z0 on an autonomous SSM. The information of SSM is given in the varargin arguments and we support both linear and nonlinear projection methods.</p><p>For <tt>projMethod=nonlinear</tt> we solve an optimization problem argmin_q <span class="MathJax_Preview"><img alt="$||z_0-W(q)||$" src="proj2SSM_eq12160416939780102997-Rescaled.png" style="width: 70.8px; height: auto;"/></span><script type="math/tex">||z_0-W(q)||</script>, where the map W gives the expansion of SSM.</p><p>For <tt>projMethod=linear</tt> we find q from z0=Vq, which is solved using the orthonormality of V and W(left eigenvectors) with respect to B matrix</p><pre class="codeinput"><span class="keyword">switch</span> projMethod
    <span class="keyword">case</span> <span class="string">'nonlinear'</span>
        W_0     = varargin{1}; <span class="comment">% expansion of SSM</span>
        autData = varargin{2}; <span class="comment">% data for mapping between real and complex coordinates</span>
        pV      = varargin{3}; <span class="comment">% initial guess of optimization</span>

        fprintf(<span class="string">'Call fminunc to find the projection of point on SSM\n'</span>);

        options = optimoptions(<span class="string">'fminunc'</span>,<span class="string">'Display'</span>,<span class="string">'notify'</span>);
        options = optimoptions(options,<span class="string">'StepTolerance'</span>,1e-10);
        options = optimoptions(options, <span class="string">'MaxFunctionEvaluations'</span>, 1e5);

        [z,fval,exitflag] = fminunc(@(u) <a href="../../../Library/Features/misc/squaDist2pointSSM.html">squaDist2pointSSM</a>(z0,u,W_0,autData), pV, options);

        <span class="comment">% convert real representation to complex one</span>
        x_real = z(autData.realx,:);
        x_comp = z(autData.compx(1:2:end-1),:)+1i*z(autData.compx(2:2:end),:);
        x  = zeros(autData.dim, 1);
        x(autData.realx,:) = x_real;
        x(autData.compx(1:2:end-1),:) = x_comp;
        x(autData.compx(2:2:end),:)   = conj(x_comp);

        varargout{1} = x;        <span class="comment">% projected point on SSM (coordinates in modal domain)</span>
        varargout{2} = fval;     <span class="comment">% squared distance to projected point</span>
        varargout{3} = exitflag; <span class="comment">% flag for convergence of optimization routine</span>

    <span class="keyword">case</span> <span class="string">'linear'</span>
        Wm = varargin{1}; <span class="comment">% left eigenvectors correspond to master spectral subspace</span>
        B  = varargin{2};
        q  = Wm'*B*z0;
        varargout{1} = q;

    <span class="keyword">otherwise</span>
        error(<span class="string">'Please select projection method to SSM from: {linear, nonlinear}'</span>);
<span class="keyword">end</span>
        </pre><pre class="codeinput"><span class="keyword">end</span>
        </pre><p class="footer"><br/><a href="https://www.mathworks.com/products/matlab/">Published with MATLABÂ® R2023a</a><br/></p></div><!--
            ##### SOURCE BEGIN #####
            %% Project onto SSM
%
%%
function varargout = proj2SSM(z0,projMethod,varargin)
%% PROJ2SSM
% 
% This function returns the projection of point z0 on an
% autonomous SSM. The information of SSM is given in the varargin arguments
% and we support both linear and nonlinear projection methods.
%
% For |projMethod=nonlinear| we solve an optimization problem argmin_q $||z_0-W(q)||$,
% where the map W gives the expansion of SSM.
%               
% For |projMethod=linear| we find q from z0=Vq, which is solved using the
% orthonormality of V and W(left eigenvectors) with respect to B matrix

switch projMethod
    case 'nonlinear'
        W_0     = varargin{1}; % expansion of SSM
        autData = varargin{2}; % data for mapping between real and complex coordinates
        pV      = varargin{3}; % initial guess of optimization

        fprintf('Call fminunc to find the projection of point on SSM\n');

        options = optimoptions('fminunc','Display','notify');
        options = optimoptions(options,'StepTolerance',1e-10);
        options = optimoptions(options, 'MaxFunctionEvaluations', 1e5);

        [z,fval,exitflag] = fminunc(@(u) <a href="../../../Library/Features/misc/squaDist2pointSSM.html">squaDist2pointSSM</a>(z0,u,W_0,autData), pV, options);
        
        % convert real representation to complex one
        x_real = z(autData.realx,:);
        x_comp = z(autData.compx(1:2:end-1),:)+1i*z(autData.compx(2:2:end),:);
        x  = zeros(autData.dim, 1);
        x(autData.realx,:) = x_real;
        x(autData.compx(1:2:end-1),:) = x_comp;
        x(autData.compx(2:2:end),:)   = conj(x_comp);

        varargout{1} = x;        % projected point on SSM (coordinates in modal domain)
        varargout{2} = fval;     % squared distance to projected point
        varargout{3} = exitflag; % flag for convergence of optimization routine
        
    case 'linear'
        Wm = varargin{1}; % left eigenvectors correspond to master spectral subspace
        B  = varargin{2};
        q  = Wm'*B*z0;
        varargout{1} = q;
        
    otherwise
        error('Please select projection method to SSM from: {linear, nonlinear}');
end
end
            ##### SOURCE END #####
        --></body></html></body></html>