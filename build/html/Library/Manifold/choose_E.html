
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><body><div class="banner"><a href="../../index.html"><img alt="Logo" class="logo" src="../../logo.png" style="float:right" width="200"/></a></div><html><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--

                    This HTML was auto-generated from MATLAB code.
                    To make changes, update the MATLAB code and republish this document.
                --><title>CHOOSE_E</title><meta content="MATLAB 9.14" name="generator"/><link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/><meta content="2023-09-09" name="DC.date"/><meta content="choose_E.m" name="DC.source"/><style type="text/css">
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

            html { min-height:100%; margin-bottom:1px; }
            html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
            html body td { vertical-align:top; text-align:left; }

            h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
            h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
            h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

            a { color:#005fce; text-decoration:none; }
            a:hover { color:#005fce; text-decoration:underline; }
            a:visited { color:#004aa0; text-decoration:none; }

            p { padding:0px; margin:0px 0px 20px; }
            img { padding:0px; margin:0px 0px 20px; border:none; }
            p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

            ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
            ul li { padding:0px; margin:0px 0px 7px 0px; }
            ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
            ul li ol li { list-style:decimal; }
            ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
            ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
            ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
            ol li ol li { list-style-type:lower-alpha; }
            ol li ul { padding-top:7px; }
            ol li ul li { list-style:square; }

            .content { font-size:1.2em; line-height:140%; padding: 20px; }

            pre, code { font-size:12px; }
            tt { font-size: 1.2em; }
            pre { margin:0px 0px 20px; }
            pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
            pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
            pre.error { color:red; }

            @media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

            span.keyword { color:#0000FF }
            span.comment { color:#228B22 }
            span.string { color:#A020F0 }
            span.untermstring { color:#B20000 }
            span.syscmd { color:#B28C00 }
            span.typesection { color:#A0522D }

            .footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
            .footer p { margin:0px; }
            .footer a { color:#878787; }
            .footer a:hover { color:#878787; text-decoration:underline; }
            .footer a:visited { color:#878787; }

            table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
            table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

            .center {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 50%;
              }



        </style></head><body><div class="content"><h1>CHOOSE_E</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">choose_E</a></li><li><a href="#4">Resonance Analysis</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span>  choose_E(obj,tangentModes)
        </pre><h2 id="2">choose_E</h2><p>This function defines the master modal subspace and performs resonance analysis. Its input is an array of indices, which indicate the set of modes over which the invariant manifold is to be computed.</p><pre class="codeinput"><span class="keyword">if</span> isempty(obj.System.spectrum)
    [~,~,~] = obj.System.<a href="../../Library/DynamicalSystem/linear_spectral_analysis.html">linear_spectral_analysis</a>();
<span class="keyword">end</span>
<span class="comment">% tangent eigenvalues</span>
nLambda = numel(obj.System.spectrum.Lambda);
lambda_M = obj.System.spectrum.Lambda(tangentModes);
<span class="comment">% normal eigenvalues</span>
normalModes = setdiff(1:nLambda,tangentModes);
lambda_S = obj.System.spectrum.Lambda(normalModes);

<span class="comment">% define subspace E</span>
obj.E.spectrum = lambda_M;
obj.E.basis = obj.System.spectrum.V(:,tangentModes);
obj.E.adjointBasis = obj.System.spectrum.W(:,tangentModes);

<span class="comment">% determine whether resonance occurs</span>
obj.resonance = resonance_analysis(lambda_M,lambda_S,obj.Options.reltol);
        </pre><pre class="codeinput"><span class="keyword">end</span>
        </pre><h2 id="4">Resonance Analysis</h2><pre class="codeinput"><span class="keyword">function</span> [resonance] = resonance_analysis(lambda_M,lambda_S,reltol)
        </pre><p>The purpose of this function is to check exisitence and uniqueness of the SSM by evaluating the non-resonance conditions between the (master and slave) modal subspaces.</p><p>It is assumed that the inputs <span class="MathJax_Preview"><img alt="$\texttt{lambda\_M, lambda\_S}$" src="choose_E_eq12652931723770574114-Rescaled.png" style="width: 120.0px; height: auto;"/></span><script type="math/tex">\texttt{lambda\_M, lambda\_S}</script> are given in the form of column vectors.</p><pre class="codeinput">m = length(lambda_M);
        </pre><p>Zero tolerance for detecting near resonances:</p><pre class="codeinput">ref = min(abs(lambda_M));
<span class="keyword">if</span> ref&lt;1e-10; ref = max(abs(lambda_M)); <span class="keyword">end</span>
abstol = reltol*ref;
        </pre><p>Maximum order upto which resonance would be checked:</p><pre class="codeinput">sigma_in_max = 10;
sigma_out_max = 10;
        </pre><p><span class="MathJax_Preview"><img alt="$$\Sigma(\mathcal{M}) = \sigma_{in} = \mathrm{Int} \left( \frac{\min \Re(\lambda_{\mathcal{M}\oplus\mathcal{S}})}{\max\Re(\lambda_{\mathcal{M}})}
\right)$$" src="choose_E_eq16989679358483267623-Rescaled.png" style="width: 204.0px; height: auto;"/></span><script type="math/tex">\Sigma(\mathcal{M}) = \sigma_{in} = \mathrm{Int} \left( \frac{\min \Re(\lambda_{\mathcal{M}\oplus\mathcal{S}})}{\max\Re(\lambda_{\mathcal{M}})}
\right)</script></p><p><span class="MathJax_Preview"><img alt="$$\sigma(\mathcal{M}) = \sigma_{out} = \mathrm{Int} \left( \frac{\min \Re(\lambda_{\mathcal{S}})}{\max\Re(\lambda_{\mathcal{M}})}
\right)$$" src="choose_E_eq10781321683870569754-Rescaled.png" style="width: 195.6px; height: auto;"/></span><script type="math/tex">\sigma(\mathcal{M}) = \sigma_{out} = \mathrm{Int} \left( \frac{\min \Re(\lambda_{\mathcal{S}})}{\max\Re(\lambda_{\mathcal{M}})}
\right)</script></p><p>When the SSM is constructed around the slowest subspace, then we have <span class="MathJax_Preview"><img alt="$\min \Re(\lambda_{\mathcal{S}}) = \min \Re(\lambda_{\mathcal{S}\oplus\mathcal{M}})$" src="choose_E_eq12148048750046365326-Rescaled.png" style="width: 152.4px; height: auto;"/></span><script type="math/tex">\min \Re(\lambda_{\mathcal{S}}) = \min \Re(\lambda_{\mathcal{S}\oplus\mathcal{M}})</script> and <span class="MathJax_Preview"><img alt="$\Sigma(\mathcal{M}) = \sigma(\mathcal{M})$" src="choose_E_eq16752105985094180436-Rescaled.png" style="width: 86.39999999999999px; height: auto;"/></span><script type="math/tex">\Sigma(\mathcal{M}) = \sigma(\mathcal{M})</script>.</p><p>Note that for 2-dimensional underdamped SSMs, <span class="MathJax_Preview"><img alt="$\Sigma(\mathcal{M}) = 1$" src="choose_E_eq14737372634845890690-Rescaled.png" style="width: 58.8px; height: auto;"/></span><script type="math/tex">\Sigma(\mathcal{M}) = 1</script> according to the above formula.</p><pre class="codeinput">lambda = [lambda_M;lambda_S];
sigma_in = fix( min(real(lambda)) / max(real(lambda_M)) );
<span class="keyword">if</span> isempty(lambda_S)
    sigma_out = 0;
<span class="keyword">else</span>
    sigma_out = fix( min(real(lambda_S)) / max(real(lambda_M)) );
<span class="keyword">end</span>
        </pre><p><b>Checking for (near) outer resonances</b></p><pre class="codeinput"><span class="keyword">if</span> sigma_out &lt; 2
    <span class="comment">% no outer (low-order) resonances can occur</span>
    resonance.outer.occurs = false;
<span class="keyword">else</span>
        </pre><p>Compute <span class="MathJax_Preview"><img alt="$\texttt{multiples}$" src="choose_E_eq06550169710844916122-Rescaled.png" style="width: 62.4px; height: auto;"/></span><script type="math/tex">\texttt{multiples}</script> of the resonant modal subspace that add up to <span class="MathJax_Preview"><img alt="$\texttt{order}$" src="choose_E_eq15072695448156311974-Rescaled.png" style="width: 33.6px; height: auto;"/></span><script type="math/tex">\texttt{order}</script>, i.e., rowsum of each row in <span class="MathJax_Preview"><img alt="$\texttt{multiples}$" src="choose_E_eq06550169710844916122-Rescaled.png" style="width: 62.4px; height: auto;"/></span><script type="math/tex">\texttt{multiples}</script> is less than or equal to <span class="MathJax_Preview"><img alt="$\texttt{order}$" src="choose_E_eq15072695448156311974-Rescaled.png" style="width: 33.6px; height: auto;"/></span><script type="math/tex">\texttt{order}</script>.</p><pre class="codeinput">    sigma_out_check = min(sigma_out_max,sigma_out);
    range = 2:sigma_out_check;
    multiples = [];
    <span class="keyword">for</span> order = range
        multiples_j = <a href="../../Library/Features/misc/nsumk.html">nsumk</a>(m,order,<span class="string">'nonnegative'</span>); <span class="comment">%  returns non-negative m-tuples summing ...</span>
                                                    <span class="comment">% exactly equal to order.</span>
        multiples = [multiples; multiples_j];
    <span class="keyword">end</span>
        </pre><p>Compute integer combinations: If <span class="MathJax_Preview"><img alt="$\mathbf{\Lambda} \in \mathbf{C}^m$" src="choose_E_eq11913306128172826941-Rescaled.png" style="width: 45.6px; height: auto;"/></span><script type="math/tex">\mathbf{\Lambda} \in \mathbf{C}^m</script> is a column vector containing the eigenvalues <span class="MathJax_Preview"><img alt="$\lambda_{\mathcal{M}}$" src="choose_E_eq16222399571247374231-Rescaled.png" style="width: 18.0px; height: auto;"/></span><script type="math/tex">\lambda_{\mathcal{M}}</script> of the master modal subspace <span class="MathJax_Preview"><img alt="$\mathcal{M}$" src="choose_E_eq16970155836551808940-Rescaled.png" style="width: 15.6px; height: auto;"/></span><script type="math/tex">\mathcal{M}</script>, then <span class="MathJax_Preview"><img alt="$\texttt{multiples}*\mathbf{\Lambda}$" src="choose_E_eq13981072044183098245-Rescaled.png" style="width: 86.39999999999999px; height: auto;"/></span><script type="math/tex">\texttt{multiples}*\mathbf{\Lambda}</script> gives a column vector containing non-negative integer combinations of these eigenvalues.</p><pre class="codeinput">    combinations = multiples * lambda_M;
    n_combinations = length(combinations);

    COMBINATIONS = repmat(combinations,[1 length(lambda_S)]);
    LAMBDA_S = repmat(lambda_S.', [n_combinations, 1]);

    [I, J] = find(abs(COMBINATIONS-LAMBDA_S)&lt;abstol);

    <span class="keyword">if</span> any(I)
        resonance.outer.occurs = true;

        disp(<span class="string">'(near) outer resonance detected for the following combination of master eigenvalues'</span>)
        resonance.outer.combinations = multiples(I,:);
        disp(resonance.outer.combinations)

        disp(<span class="string">'These are in resonance with the follwing eigenvalues of the slave subspace'</span>)
        resonance.outer.eigs = lambda_S(J);
        disp(resonance.outer.eigs)
    <span class="keyword">else</span>
        disp(<span class="string">'No (near) outer resonances detected in the (truncated) spectrum'</span>)
        resonance.outer.occurs = false;
    <span class="keyword">end</span>
        </pre><pre class="codeinput"><span class="keyword">end</span>

resonance.outer.sigma = sigma_out;
disp([<span class="string">'sigma_out = '</span> num2str(sigma_out)])
        </pre><p><b>Checking for near-inner resonances</b></p><pre class="codeinput"><span class="keyword">if</span> sigma_in &lt; 2
    <span class="comment">% no inner (higher-order) resonances can occur</span>
    resonance.inner.occurs = false;
<span class="keyword">else</span>
        </pre><p>Compute integer combinations: If <span class="MathJax_Preview"><img alt="$\mathbf{\Lambda} \in \mathbf{C}^m$" src="choose_E_eq11913306128172826941-Rescaled.png" style="width: 45.6px; height: auto;"/></span><script type="math/tex">\mathbf{\Lambda} \in \mathbf{C}^m</script> is a column vector containing the eigenvalues <span class="MathJax_Preview"><img alt="$\lambda_{\mathcal{M}}$" src="choose_E_eq16222399571247374231-Rescaled.png" style="width: 18.0px; height: auto;"/></span><script type="math/tex">\lambda_{\mathcal{M}}</script> of the master modal subspace <span class="MathJax_Preview"><img alt="$\mathcal{M}$" src="choose_E_eq16970155836551808940-Rescaled.png" style="width: 15.6px; height: auto;"/></span><script type="math/tex">\mathcal{M}</script>, then <span class="MathJax_Preview"><img alt="$\texttt{multiples}*\mathbf{\Lambda}$" src="choose_E_eq13981072044183098245-Rescaled.png" style="width: 86.39999999999999px; height: auto;"/></span><script type="math/tex">\texttt{multiples}*\mathbf{\Lambda}</script> gives a column vector containing non-negative integer combinations of these eigenvalues.</p><pre class="codeinput">    sigma_in_check = min(sigma_in_max,sigma_in);
    range = 2:sigma_in_check;
    multiples = [];
    <span class="keyword">for</span> order = range
        multiples_j = <a href="../../Library/Features/misc/nsumk.html">nsumk</a>(m,order,<span class="string">'nonnegative'</span>); <span class="comment">%  returns non-negative m-tuples summing...</span>
                                                    <span class="comment">% exactly equal to order.</span>
        multiples = [multiples; multiples_j];
    <span class="keyword">end</span>

    combinations = multiples * lambda_M;
    n_combinations = length(combinations);
    COMBINATIONS = repmat(combinations,[1 length(lambda_M)]);
    LAMBDA_M = repmat(lambda_M.', [n_combinations, 1]);

    [I, J] = find(abs(COMBINATIONS-LAMBDA_M)&lt;abstol);

    <span class="keyword">if</span> any(I)
        resonance.inner.occurs = true;

        disp(<span class="string">'(near) inner resonance detected for the following combination of master eigenvalues'</span>)
        resonance.inner.combinations = multiples(I,:);
        disp(resonance.inner.combinations)

        disp(<span class="string">'These are in resonance with the follwing eigenvalues of the master subspace'</span>)
        resonance.inner.eigs = lambda_M(J);
        disp(resonance.inner.eigs)
    <span class="keyword">else</span>
        disp(<span class="string">'No (near) inner resonances detected in the (truncated) spectrum'</span>)
        resonance.inner.occurs = false;
    <span class="keyword">end</span>
        </pre><pre class="codeinput"><span class="keyword">end</span>

resonance.inner.sigma = sigma_in;
disp([<span class="string">'sigma_in = '</span> num2str(sigma_in)])
        </pre><pre class="codeinput"><span class="keyword">end</span>
        </pre><p class="footer"><br/><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2023a</a><br/></p></div><!--
            ##### SOURCE BEGIN #####
            %% CHOOSE_E
%
%%
function  choose_E(obj,tangentModes)
%% choose_E
% This function defines the master modal subspace and performs
% resonance analysis. Its input is an array of indices, which indicate the
% set of modes over which the invariant manifold is to be computed.

if isempty(obj.System.spectrum)
    [~,~,~] = obj.System.<a href="../../Library/DynamicalSystem/linear_spectral_analysis.html">linear_spectral_analysis</a>();
end
% tangent eigenvalues
nLambda = numel(obj.System.spectrum.Lambda);
lambda_M = obj.System.spectrum.Lambda(tangentModes);
% normal eigenvalues
normalModes = setdiff(1:nLambda,tangentModes);
lambda_S = obj.System.spectrum.Lambda(normalModes);

% define subspace E
obj.E.spectrum = lambda_M;
obj.E.basis = obj.System.spectrum.V(:,tangentModes);
obj.E.adjointBasis = obj.System.spectrum.W(:,tangentModes);

% determine whether resonance occurs
obj.resonance = resonance_analysis(lambda_M,lambda_S,obj.Options.reltol);
end

%% Resonance Analysis
%
function [resonance] = resonance_analysis(lambda_M,lambda_S,reltol)
%% 
% The purpose of this function is to check exisitence and uniqueness of the 
% SSM by evaluating the non-resonance conditions between the (master and slave) 
% modal subspaces.
% 
% It is assumed that the inputs $\texttt{lambda\_M, lambda\_S}$ are given in 
% the form of column vectors.

m = length(lambda_M);
%% 
% Zero tolerance for detecting near resonances:

ref = min(abs(lambda_M));
if ref<1e-10; ref = max(abs(lambda_M)); end
abstol = reltol*ref;
%% 
% Maximum order upto which resonance would be checked:

sigma_in_max = 10;
sigma_out_max = 10;
%% 
% $$\Sigma(\mathcal{M}) = \sigma_{in} = \mathrm{Int} \left( \frac{\min \Re(\lambda_{\mathcal{M}\oplus\mathcal{S}})}{\max\Re(\lambda_{\mathcal{M}})} 
% \right)$$
% 
% $$\sigma(\mathcal{M}) = \sigma_{out} = \mathrm{Int} \left( \frac{\min \Re(\lambda_{\mathcal{S}})}{\max\Re(\lambda_{\mathcal{M}})} 
% \right)$$
% 
% When the SSM is constructed around the slowest subspace, then we have $\min 
% \Re(\lambda_{\mathcal{S}}) = \min \Re(\lambda_{\mathcal{S}\oplus\mathcal{M}})$ 
% and $\Sigma(\mathcal{M}) = \sigma(\mathcal{M})$.
% 
% Note that for 2-dimensional underdamped SSMs, $\Sigma(\mathcal{M}) = 1$ according 
% to the above formula.

lambda = [lambda_M;lambda_S];
sigma_in = fix( min(real(lambda)) / max(real(lambda_M)) );
if isempty(lambda_S)
    sigma_out = 0;
else
    sigma_out = fix( min(real(lambda_S)) / max(real(lambda_M)) );
end
%% 
% *Checking for (near) outer resonances*

if sigma_out < 2
    % no outer (low-order) resonances can occur
    resonance.outer.occurs = false;
else
%% 
% Compute $\texttt{multiples}$ of the resonant modal subspace that add up to 
% $\texttt{order}$, i.e., rowsum of each row in $\texttt{multiples}$ is less than 
% or equal to $\texttt{order}$.

    sigma_out_check = min(sigma_out_max,sigma_out);
    range = 2:sigma_out_check;
    multiples = [];
    for order = range
        multiples_j = <a href="../../Library/Features/misc/nsumk.html">nsumk</a>(m,order,'nonnegative'); %  returns non-negative m-tuples summing ...
                                                    % exactly equal to order.
        multiples = [multiples; multiples_j];
    end
%% 
% Compute integer combinations: If $\mathbf{\Lambda} \in \mathbf{C}^m$ is a 
% column vector containing the eigenvalues $\lambda_{\mathcal{M}}$ of the master 
% modal subspace $\mathcal{M}$, then $\texttt{multiples}*\mathbf{\Lambda}$ gives 
% a column vector containing non-negative integer combinations of these eigenvalues.

    combinations = multiples * lambda_M;
    n_combinations = length(combinations);
    
    COMBINATIONS = repmat(combinations,[1 length(lambda_S)]);
    LAMBDA_S = repmat(lambda_S.', [n_combinations, 1]);
    
    [I, J] = find(abs(COMBINATIONS-LAMBDA_S)<abstol);
    
    if any(I)
        resonance.outer.occurs = true;
        
        disp('(near) outer resonance detected for the following combination of master eigenvalues')
        resonance.outer.combinations = multiples(I,:);
        disp(resonance.outer.combinations)
        
        disp('These are in resonance with the follwing eigenvalues of the slave subspace')
        resonance.outer.eigs = lambda_S(J);
        disp(resonance.outer.eigs)
    else
        disp('No (near) outer resonances detected in the (truncated) spectrum')
        resonance.outer.occurs = false;
    end
    
end

resonance.outer.sigma = sigma_out;
disp(['sigma_out = ' num2str(sigma_out)])
%% 
% *Checking for near-inner resonances*

if sigma_in < 2
    % no inner (higher-order) resonances can occur
    resonance.inner.occurs = false;
else    
    
%% 
% Compute integer combinations: If $\mathbf{\Lambda} \in \mathbf{C}^m$ is a 
% column vector containing the eigenvalues $\lambda_{\mathcal{M}}$ of the master 
% modal subspace $\mathcal{M}$, then $\texttt{multiples}*\mathbf{\Lambda}$ gives 
% a column vector containing non-negative integer combinations of these eigenvalues.


    sigma_in_check = min(sigma_in_max,sigma_in);
    range = 2:sigma_in_check;
    multiples = [];
    for order = range
        multiples_j = <a href="../../Library/Features/misc/nsumk.html">nsumk</a>(m,order,'nonnegative'); %  returns non-negative m-tuples summing...
                                                    % exactly equal to order.
        multiples = [multiples; multiples_j];
    end
    
    combinations = multiples * lambda_M;
    n_combinations = length(combinations);
    COMBINATIONS = repmat(combinations,[1 length(lambda_M)]);
    LAMBDA_M = repmat(lambda_M.', [n_combinations, 1]);    
    
    [I, J] = find(abs(COMBINATIONS-LAMBDA_M)<abstol);
    
    if any(I)
        resonance.inner.occurs = true;
        
        disp('(near) inner resonance detected for the following combination of master eigenvalues')
        resonance.inner.combinations = multiples(I,:);
        disp(resonance.inner.combinations)
        
        disp('These are in resonance with the follwing eigenvalues of the master subspace')
        resonance.inner.eigs = lambda_M(J);
        disp(resonance.inner.eigs)
    else
        disp('No (near) inner resonances detected in the (truncated) spectrum')
        resonance.inner.occurs = false;
    end
end

resonance.inner.sigma = sigma_in;
disp(['sigma_in = ' num2str(sigma_in)])
end
            ##### SOURCE END #####
        --></body></html></body></html>