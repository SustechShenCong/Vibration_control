
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><body><div class="banner"><a href="../../../index.html"><img alt="Logo" class="logo" src="../../../logo.png" style="float:right" width="200"/></a></div><html><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--

                    This HTML was auto-generated from MATLAB code.
                    To make changes, update the MATLAB code and republish this document.
                --><title>COMPUTE_PI</title><meta content="MATLAB 9.14" name="generator"/><link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/><meta content="2023-09-09" name="DC.date"/><meta content="compute_pi.m" name="DC.source"/><style type="text/css">
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

            html { min-height:100%; margin-bottom:1px; }
            html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
            html body td { vertical-align:top; text-align:left; }

            h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
            h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
            h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

            a { color:#005fce; text-decoration:none; }
            a:hover { color:#005fce; text-decoration:underline; }
            a:visited { color:#004aa0; text-decoration:none; }

            p { padding:0px; margin:0px 0px 20px; }
            img { padding:0px; margin:0px 0px 20px; border:none; }
            p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

            ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
            ul li { padding:0px; margin:0px 0px 7px 0px; }
            ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
            ul li ol li { list-style:decimal; }
            ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
            ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
            ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
            ol li ol li { list-style-type:lower-alpha; }
            ol li ul { padding-top:7px; }
            ol li ul li { list-style:square; }

            .content { font-size:1.2em; line-height:140%; padding: 20px; }

            pre, code { font-size:12px; }
            tt { font-size: 1.2em; }
            pre { margin:0px 0px 20px; }
            pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
            pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
            pre.error { color:red; }

            @media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

            span.keyword { color:#0000FF }
            span.comment { color:#228B22 }
            span.string { color:#A020F0 }
            span.untermstring { color:#B20000 }
            span.syscmd { color:#B28C00 }
            span.typesection { color:#A0522D }

            .footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
            .footer p { margin:0px; }
            .footer a { color:#878787; }
            .footer a:hover { color:#878787; text-decoration:underline; }
            .footer a:visited { color:#878787; }

            table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
            table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

            .center {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 50%;
              }



        </style></head><body><div class="content"><h1>COMPUTE_PI</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Compute composition of powers series.</a></li><li><a href="#4">Read results into output array</a></li><li><a href="#5">Special case</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [pis] = compute_pi(n_mat,k_mat, field)
        </pre><h2 id="2">Compute composition of powers series.</h2><p>Computes pi_n_k for every combination of multi-indices in the two input matrices Multi index arrays n_mat and k_mat need to contain multi indices of same order <tt>n</tt> and <tt>k</tt> resepectively Pi are the forcing contribution coefficients resulting from composition with the SSM parametrisation.</p><pre class="codeinput">n_pos_idx = any(n_mat);
k_pos_idx = any(k_mat);

<span class="comment">% No calculations for zero multi-indices needed</span>
n_zero_idx = find(~n_pos_idx);
k_zero_idx = find(~k_pos_idx);

<span class="keyword">switch</span> field.ordering
    <span class="keyword">case</span> <span class="string">'revlex'</span>

        pis_pos = pink(n_mat(:,n_pos_idx),k_mat(:,k_pos_idx), field);

    <span class="keyword">case</span> <span class="string">'conjugate'</span>
        <span class="comment">%Needs all multi-indices in n_mat and k_mat to have same order</span>
        pis_pos = pink_conj(n_mat(:,n_pos_idx),k_mat(:,k_pos_idx),field);
<span class="keyword">end</span>
        </pre><h2 id="4">Read results into output array</h2><pre class="codeinput"><span class="comment">%insert zero columns</span>
<span class="keyword">if</span> ~isempty(k_zero_idx)
    pis_cols = zeros(size(pis_pos,1),size(k_mat,2));
    pis_cols(:,k_pos_idx) = pis_pos;
<span class="keyword">else</span>
    pis_cols = pis_pos;
<span class="keyword">end</span>

<span class="comment">%insert zero rows</span>
<span class="keyword">if</span> ~isempty(n_zero_idx)
    pis = zeros(size(n_mat,2),size(k_mat,2));
    pis(n_pos_idx,:) = pis_cols;
<span class="keyword">else</span>
    pis = pis_cols;
<span class="keyword">end</span>
        </pre><h2 id="5">Special case</h2><p>fill pis with ones where k and n_mat both have a zero multiindex</p><pre class="codeinput"><span class="keyword">for</span> n_i = n_zero_idx
    <span class="keyword">for</span> k_i = k_zero_idx
        pis(n_i,k_i) = 1;
    <span class="keyword">end</span>
<span class="keyword">end</span>
        </pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> [pis] = pink(n_mat,K,field)
        </pre><pre class="codeinput">assert(nnz(n_mat&lt;0)==0,<span class="string">'Negative multiindices'</span>)
        </pre><p>Conjugate center index at all orders, for imaginary system this is empty since then no symmetry is inherent and we only need the number of multi-indices that exist at order k, given by nchoosek(k+l-1,l-1)</p><pre class="codeinput">l           = size(K,1);        <span class="comment">% SSM dimension</span>
z_k         = size(K,2);
<span class="comment">% Phase space dimension</span>
N           = size(n_mat,1);
<span class="comment">% nonzero entries in the multi-index array</span>
F_multi_pos   = (n_mat ~= 0);
sz          = size(n_mat,2);
col_pos     = 1:sz;
        </pre><p>Initialise space for the <span class="MathJax_Preview"><img alt="$\pi_{\mathbf{m},\mathbf{k}_f}$" src="compute_pi_eq02458074943802699371-Rescaled.png" style="width: 28.799999999999997px; height: auto;"/></span><script type="math/tex">\pi_{\mathbf{m},\mathbf{k}_f}</script>.</p><pre class="codeinput">pis = zeros(size(col_pos,2),z_k);
        </pre><p>The array <span class="MathJax_Preview"><img alt="$\texttt{sz\_pos}$" src="compute_pi_eq07307310309999988163-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_pos}</script> is a row vector containing in each row the number of nonzero entries of the multi-index the row corresponds to. This is useful, since <span class="MathJax_Preview"><img alt="$H_{i,0,\mathbf{h}} = 0$" src="compute_pi_eq06950165298109173078-Rescaled.png" style="width: 55.199999999999996px; height: auto;"/></span><script type="math/tex">H_{i,0,\mathbf{h}} = 0</script> for any nonzero <span class="MathJax_Preview"><img alt="$\mathbf{h}$" src="compute_pi_eq13551287546431487114-Rescaled.png" style="width: 8.4px; height: auto;"/></span><script type="math/tex">\mathbf{h}</script>. Therefore for each <span class="MathJax_Preview"><img alt="$\mathbf{m}$" src="compute_pi_eq03598573572044437231-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{m}</script> in <span class="MathJax_Preview"><img alt="$\texttt{F\_multi}$" src="compute_pi_eq18041254262223804567-Rescaled.png" style="width: 45.6px; height: auto;"/></span><script type="math/tex">\texttt{F\_multi}</script> we only have to find the composition coefficients corresponding to the nonzero entries of <span class="MathJax_Preview"><img alt="$\mathbf{m}$" src="compute_pi_eq03598573572044437231-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{m}</script>. Furthermore then condition 1 looks like <span class="MathJax_Preview"><img alt="$\sum_{v,m_v \neq 0} \mathbf{h}_v = \mathbf{k}_f$" src="compute_pi_eq14018137582768259288-Rescaled.png" style="width: 92.39999999999999px; height: auto;"/></span><script type="math/tex">\sum_{v,m_v \neq 0} \mathbf{h}_v = \mathbf{k}_f</script>. For each <span class="MathJax_Preview"><img alt="$f$" src="compute_pi_eq02527148203711597490-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">f</script> and <span class="MathJax_Preview"><img alt="$\mathbf{m}$" src="compute_pi_eq03598573572044437231-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{m}</script> all such combinations have to be found.</p><pre class="codeinput">sz_pos   = sum(F_multi_pos,1);
        </pre><p>This function computes all those combinations for all order <span class="MathJax_Preview"><img alt="$m$" src="compute_pi_eq18216620034067401164-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">m</script> multi-indices <span class="MathJax_Preview"><img alt="$\mathbf{m}$" src="compute_pi_eq03598573572044437231-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{m}</script> and all <span class="MathJax_Preview"><img alt="$f$" src="compute_pi_eq02527148203711597490-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">f</script>. It does so by considering unique numbers in <span class="MathJax_Preview"><img alt="$\texttt{sz\_pos}$" src="compute_pi_eq07307310309999988163-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_pos}</script> and using them as the number of multi-indices <span class="MathJax_Preview"><img alt="$\mathbf{h}_i$" src="compute_pi_eq04515425204478813704-Rescaled.png" style="width: 10.799999999999999px; height: auto;"/></span><script type="math/tex">\mathbf{h}_i</script> that have to sum up to <span class="MathJax_Preview"><img alt="$\mathbf{k}_f$" src="compute_pi_eq12788223238356508156-Rescaled.png" style="width: 14.399999999999999px; height: auto;"/></span><script type="math/tex">\mathbf{k}_f</script> for all <span class="MathJax_Preview"><img alt="$f$" src="compute_pi_eq02527148203711597490-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">f</script>.</p><p><span class="MathJax_Preview"><img alt="$\texttt{h}$" src="compute_pi_eq13958417881461454476-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">\texttt{h}</script> is a cell array, that contains in its first dimension the combinations for all <span class="MathJax_Preview"><img alt="$f$" src="compute_pi_eq02527148203711597490-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">f</script> and its second dimension corresponds to unique numbers in <span class="MathJax_Preview"><img alt="$\texttt{sz\_pos}$" src="compute_pi_eq07307310309999988163-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_pos}</script>. They are stored in <span class="MathJax_Preview"><img alt="$\texttt{sz\_un}$" src="compute_pi_eq01051170770119728142-Rescaled.png" style="width: 32.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un}</script>. For each entry in <span class="MathJax_Preview"><img alt="$\texttt{sz\_pos}$" src="compute_pi_eq07307310309999988163-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_pos}</script> the corresponding entry in <span class="MathJax_Preview"><img alt="$\texttt{sz\_un\_ic}$" src="compute_pi_eq14055223087504850512-Rescaled.png" style="width: 50.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un\_ic}</script> gives the column that it corresponds to in <span class="MathJax_Preview"><img alt="$\texttt{h}$" src="compute_pi_eq13958417881461454476-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">\texttt{h}</script>.</p><p><span class="MathJax_Preview"><img alt="$\texttt{h\{f,i\}}$" src="compute_pi_eq06440395696489239162-Rescaled.png" style="width: 40.8px; height: auto;"/></span><script type="math/tex">\texttt{h\{f,i\}}</script> contains a 3 dimensional array. The first dimension has size <span class="MathJax_Preview"><img alt="$l$" src="compute_pi_eq17216086743898025322-Rescaled.png" style="width: 3.5999999999999996px; height: auto;"/></span><script type="math/tex">l</script>, the second hase size <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script>. Its third dimension has size <span class="MathJax_Preview"><img alt="$\texttt{combnos(i)}$" src="compute_pi_eq05682266413850064750-Rescaled.png" style="width: 67.2px; height: auto;"/></span><script type="math/tex">\texttt{combnos(i)}</script>.</p><p>This array contains in every matrix a set <span class="MathJax_Preview"><img alt="$\{\mathbf{h}_{v}\}_{v}$" src="compute_pi_eq16573582683439618002-Rescaled.png" style="width: 31.2px; height: auto;"/></span><script type="math/tex">\{\mathbf{h}_{v}\}_{v}</script> that fulfills condition 1 for <span class="MathJax_Preview"><img alt="$\mathbf{k}_f$" src="compute_pi_eq12788223238356508156-Rescaled.png" style="width: 14.399999999999999px; height: auto;"/></span><script type="math/tex">\mathbf{k}_f</script> that is stored in <span class="MathJax_Preview"><img alt="$\texttt{K2(:,f)}$" src="compute_pi_eq13807961323307379716-Rescaled.png" style="width: 46.8px; height: auto;"/></span><script type="math/tex">\texttt{K2(:,f)}</script>. Each set consists of <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> elements.</p><p><span class="MathJax_Preview"><img alt="$\texttt{combnos}$" src="compute_pi_eq10923592312068766590-Rescaled.png" style="width: 48.0px; height: auto;"/></span><script type="math/tex">\texttt{combnos}</script> contains the amount of combinations that exist for every tuple <span class="MathJax_Preview"><img alt="$(\texttt{f,i})$" src="compute_pi_eq06605613369182313080-Rescaled.png" style="width: 28.799999999999997px; height: auto;"/></span><script type="math/tex">(\texttt{f,i})</script>.</p><pre class="codeinput">[h, combnos,sz_un,sz_un_ic] = multi_<a href="../../../Library/Features/misc/nsumk.html">nsumk</a>(sz_pos,K);
<span class="comment">%stores the order of all the multi-indices in h</span>
h_abs = cellfun(@(x) reshape(sum(x,1),size(x,2),[]), h, <span class="string">'UniformOutput'</span>,false);

<span class="comment">%loop over all the order k multi-indices with index below center</span>
<span class="comment">%index in conjugate ordering</span>
<span class="keyword">for</span> f = 1:z_k

    <span class="comment">%loop over unique amounts of nonzero entries in the</span>
    <span class="comment">%multi-indices m</span>
    <span class="keyword">for</span> i = 1:size(sz_un,2)
        </pre><pre class="codeinput">        <span class="comment">%position of multi-indices in F_multi that have sz_un(i) nonzero entries</span>
        idx    = sz_un_ic == i;

        <span class="comment">%number of multi-indices in F_multi that have i nonzero entries</span>
        sumidx = sum(idx);

        <span class="keyword">if</span> sz_un(i) == 0
            <span class="keyword">if</span> nnz(K(:,f)) == 0
               pis(idx,f) = ones(sumidx,1);
            <span class="keyword">end</span>
            <span class="keyword">continue</span>
        <span class="keyword">end</span>

        <span class="comment">%columns of Fm that contain i nonzero elements</span>
        n_idx         = n_mat(:,idx.');
        n_idx_find    = find(n_idx);
        [n_idx_row,~] = ind2sub(size(n_idx),n_idx_find);
        </pre><p><span class="MathJax_Preview"><img alt="$\texttt{Fm\_idx\_pos}$" src="compute_pi_eq13441206244026983017-Rescaled.png" style="width: 66.0px; height: auto;"/></span><script type="math/tex">\texttt{Fm\_idx\_pos}</script> contains the entries of <span class="MathJax_Preview"><img alt="$\texttt{F\_multi}$" src="compute_pi_eq18041254262223804567-Rescaled.png" style="width: 45.6px; height: auto;"/></span><script type="math/tex">\texttt{F\_multi}</script> that correspond to the multi-indices that have <span class="MathJax_Preview"><img alt="$i$" src="compute_pi_eq08984912804010224726-Rescaled.png" style="width: 4.8px; height: auto;"/></span><script type="math/tex">i</script> nonzero elements. It is therefore a  <span class="MathJax_Preview"><img alt="$\texttt{sumidx *sz\_un(i)}$" src="compute_pi_eq18077958322521653699-Rescaled.png" style="width: 106.8px; height: auto;"/></span><script type="math/tex">\texttt{sumidx *sz\_un(i)}</script> by 1 array.</p><pre class="codeinput">        n_idx_pos     = n_idx(n_idx_find);
        </pre><p>This step checks where condition 2 is fulfilled. <span class="MathJax_Preview"><img alt="$\texttt{h\_abs\{f,i\}}$" src="compute_pi_eq10750961844098868105-Rescaled.png" style="width: 67.2px; height: auto;"/></span><script type="math/tex">\texttt{h\_abs\{f,i\}}</script> contains a <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> by <span class="MathJax_Preview"><img alt="$\texttt{combnos(i)}$" src="compute_pi_eq05682266413850064750-Rescaled.png" style="width: 67.2px; height: auto;"/></span><script type="math/tex">\texttt{combnos(i)}</script> dimensionaly array. In every column it contains the absolute values of all multi_indices of one combination <span class="MathJax_Preview"><img alt="$\{\mathbf{h}_v\}_v$" src="compute_pi_eq09845584587950433315-Rescaled.png" style="width: 31.2px; height: auto;"/></span><script type="math/tex">\{\mathbf{h}_v\}_v</script> that fulfills condition 1 for <span class="MathJax_Preview"><img alt="$\texttt{f}$" src="compute_pi_eq06745379350049732521-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">\texttt{f}</script> and contains <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> elements. Condition 2 is checked simultaneously for all <span class="MathJax_Preview"><img alt="$\mathbf{m}$" src="compute_pi_eq03598573572044437231-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{m}</script> of order <span class="MathJax_Preview"><img alt="$\texttt{order}$" src="compute_pi_eq15072695448156311974-Rescaled.png" style="width: 33.6px; height: auto;"/></span><script type="math/tex">\texttt{order}</script> that contain <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> nonzero entries.</p><p><span class="MathJax_Preview"><img alt="$$\texttt{h\_abs\{f,i\}} = \pmatrix{ \mathbf{h_1^1} &amp; \cdots &amp; \mathbf{h_1^\texttt{combnos(i)}}\cr
\mathbf{h_2^1} &amp; \cdots &amp; \mathbf{h_2^\texttt{combnos(i)}}\cr \vdots &amp; \cdots
&amp; \vdots\cr \mathbf{h_{\texttt{sz\_un(i)}}^1} &amp; \cdots &amp; \mathbf{h_{\texttt{sz\_un(i)}}^\texttt{combnos(i)}}}
$$" src="compute_pi_eq15361356171136157777-Rescaled.png" style="width: 290.4px; height: auto;"/></span><script type="math/tex">\texttt{h\_abs\{f,i\}} = \pmatrix{ \mathbf{h_1^1} & \cdots & \mathbf{h_1^\texttt{combnos(i)}}\cr
\mathbf{h_2^1} & \cdots & \mathbf{h_2^\texttt{combnos(i)}}\cr \vdots & \cdots
& \vdots\cr \mathbf{h_{\texttt{sz\_un(i)}}^1} & \cdots & \mathbf{h_{\texttt{sz\_un(i)}}^\texttt{combnos(i)}}}
</script></p><p>And therefore if the size <span class="MathJax_Preview"><img alt="$2n$" src="compute_pi_eq04129684908155159413-Rescaled.png" style="width: 14.399999999999999px; height: auto;"/></span><script type="math/tex">2n</script> multi indices that have <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> nonzero elements are <span class="MathJax_Preview"><img alt="$\mathbf{m}_1, ... , \mathbf{m}_\texttt{sumidx}$" src="compute_pi_eq18197536538755691665-Rescaled.png" style="width: 94.8px; height: auto;"/></span><script type="math/tex">\mathbf{m}_1, ... , \mathbf{m}_\texttt{sumidx}</script>, and we define <span class="MathJax_Preview"><img alt="$\mathbf{m}_1^+$" src="compute_pi_eq17098975814225806447-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_1^+</script> as the size <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> multi-index containing the nonzero elements of <span class="MathJax_Preview"><img alt="$\mathbf{m}_1$" src="compute_pi_eq01085214355710257986-Rescaled.png" style="width: 16.8px; height: auto;"/></span><script type="math/tex">\mathbf{m}_1</script>,then condition 2 is checked as follows:</p><p><span class="MathJax_Preview"><img alt="$$\texttt{Cond\_dum} = \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_1^+\cr\texttt{h\_abs\{f,i\}}
==  \mathbf{m}_2^+ \cr \vdots \cr\texttt{h\_abs\{f,i\}}==
\mathbf{m}_\texttt{sumidx}^+} \in \mathbf{N} \textrm{mod 2}^{\texttt{sumidx}\ \times \ \texttt{combnos(i) }}$$" src="compute_pi_eq10512552581079749376-Rescaled.png" style="width: 436.8px; height: auto;"/></span><script type="math/tex">\texttt{Cond\_dum} = \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_1^+\cr\texttt{h\_abs\{f,i\}}
==  \mathbf{m}_2^+ \cr \vdots \cr\texttt{h\_abs\{f,i\}}==
\mathbf{m}_\texttt{sumidx}^+} \in \mathbf{N} \textrm{mod 2}^{\texttt{sumidx}\ \times \ \texttt{combnos(i) }}</script></p><pre class="codeinput">        Cond_dum = repmat(h_abs{f,i},sumidx,1) &gt;= full(n_idx_pos);
        </pre><p>Now we would like to check which combinations fulfill condition 2 for all of their elements. This corresponds to columns of <span class="MathJax_Preview"><img alt="$\texttt{h\_abs\{f,i\}} == \mathbf{m}_j^+$" src="compute_pi_eq12047648062529164767-Rescaled.png" style="width: 114.0px; height: auto;"/></span><script type="math/tex">\texttt{h\_abs\{f,i\}} == \mathbf{m}_j^+</script> where all elements are one. So summing over the rows only the columns that have <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> as their entry correspond to valid combinations that fulfill condition 2to for <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script>, and this has to be done for <span class="MathJax_Preview"><img alt="$j = 1,...,\texttt{sumidx}$" src="compute_pi_eq08307348901538058802-Rescaled.png" style="width: 94.8px; height: auto;"/></span><script type="math/tex">j = 1,...,\texttt{sumidx}</script>.</p><p>To do this we transpose <span class="MathJax_Preview"><img alt="$\texttt{Cond\_dum}$" src="compute_pi_eq04341677538977575504-Rescaled.png" style="width: 54.0px; height: auto;"/></span><script type="math/tex">\texttt{Cond\_dum}</script> and permute the first two dimensions. Furthermore, now a third dimension is added which each corresponds to one <span class="MathJax_Preview"><img alt="$\mathbf{m}_i^+$" src="compute_pi_eq13217126165152531061-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_i^+</script>. reshape, such that every slice of 3rd dim corresponds to conditions for one m, first dimension</p><pre class="codeinput">        Cond_dum = reshape(Cond_dum.',[],sz_un(i),sumidx);

        <span class="comment">% permute, every column now contains conds for one combo of</span>
        <span class="comment">% h_is, sum all those cond values, if they are all one in a</span>
        <span class="comment">% column, they contribute.</span>
        Cond_dum =  sum(permute( Cond_dum,[2,1,3]),1);
        </pre><p>Now a slice of the third dimension looks like <span class="MathJax_Preview"><img alt="$\texttt{Cond\_dum(:,:,j)} = \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_j^+} $. The sum over the rows reveals which combos contribute. The resulting vector is recast, such that every column corresponds to one $\mathbf{m}_j^+$" src="compute_pi_eq18295123890301697593-Rescaled.png" style="width: 1040.3999999999999px; height: auto;"/></span><script type="math/tex">\texttt{Cond\_dum(:,:,j)} = \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_j^+} $. The sum over the rows reveals which combos contribute. The resulting vector is recast, such that every column corresponds to one $\mathbf{m}_j^+</script> and the rows correspond to the combinations that fulfill condition 1. The ones that also fulfill condition 2 are logical ones, the others are zero.</p><pre class="codeinput">        <span class="comment">% check if every vector of a combo fulfills cond, if not</span>
        <span class="comment">% discard it</span>
        Cond     = sparse(reshape(Cond_dum == full(sz_un(i)),combnos(f,i),[] ));

        <span class="keyword">if</span> nnz(Cond)==0
            <span class="keyword">continue</span>
        <span class="keyword">end</span>
        </pre><p>The array indices reads out the index of the valid combinations. Specifically if the different combinations are numbered with numbers 1 to <span class="MathJax_Preview"><img alt="$\texttt{combnos(f,i)}$" src="compute_pi_eq06000355065613730742-Rescaled.png" style="width: 80.39999999999999px; height: auto;"/></span><script type="math/tex">\texttt{combnos(f,i)}</script>, then it assigns every valid combination the number it corresponds to.</p><pre class="codeinput">        <span class="comment">%contains indices to read out the ones fulfilling cond2</span>
        <span class="comment">%from h</span>
        indices  = repmat([1:combnos(f,i)].',1,sumidx);
        Cond_ind = indices(Cond);
        </pre><p>Consequently all valid combinations of multi-indices are explicitly read out into a array that contains all of the multi-indices in its second dimension. All valid combinations for <span class="MathJax_Preview"><img alt="$\mathbf{m}_1^+$" src="compute_pi_eq17098975814225806447-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_1^+</script> are in it as a sequence, followed by all valid combinations for <span class="MathJax_Preview"><img alt="$\mathbf{m}_2^+$" src="compute_pi_eq02359984336574730220-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_2^+</script> and so forth.</p><pre class="codeinput">        <span class="comment">%All combos in first dim. each combo has nns(ind)</span>
        <span class="comment">%contributions - to get back, reshape to l, nns(ind), []</span>
        h_i      = reshape( h{f,i}(:,:,reshape(Cond_ind,[],1)) ,l,[]);
        </pre><p>In order to read out the composition coefficients corresponding to all those multi-indices we have to know their position in a set of reverse lexicographical ordering of all multi-indices of their respective order and size. In order to do this efficient, unique multi-indices are extracted from <span class="MathJax_Preview"><img alt="$\texttt{h\_i}$" src="compute_pi_eq12776834098194855038-Rescaled.png" style="width: 18.0px; height: auto;"/></span><script type="math/tex">\texttt{h\_i}</script>, and their position is calculated, in either conjugate ordering (real system) or in reverse lex. ordering (non real system). Then the subindices of all multi-indices are stored in the array <span class="MathJax_Preview"><img alt="$\texttt{h\_i\_multi}$" src="compute_pi_eq08109281396480677099-Rescaled.png" style="width: 57.599999999999994px; height: auto;"/></span><script type="math/tex">\texttt{h\_i\_multi}</script>.</p><pre class="codeinput">        [h_i_un,~,h_i_ic] = unique(h_i.',<span class="string">'rows'</span>);
        h_i_idx_temp    = <a href="../../../Library/Manifold/private/multi_index_2_ordering.html">multi_index_2_ordering</a>(h_i_un.',<span class="string">'revlex'</span>,[]);
        h_i_idx         = h_i_idx_temp(h_i_ic.');
        </pre><p>To read out the composition coefficients at the right order the absolute values of the multi-indices also has to be known. They are stored in <span class="MathJax_Preview"><img alt="$\texttt{h\_i\_abs}$" src="compute_pi_eq07944577750347267428-Rescaled.png" style="width: 44.4px; height: auto;"/></span><script type="math/tex">\texttt{h\_i\_abs}</script>.</p><pre class="codeinput">        <span class="keyword">if</span> l &gt; 1
            h_i_abs    = sum(h_i_un.');
        <span class="keyword">else</span>
            h_i_abs = h_i_un.';
        <span class="keyword">end</span>
        [h_i_abs_un,~,h_i_abs_ic] = unique(h_i_abs);
        </pre><p><span class="MathJax_Preview"><img alt="$\texttt{list\_1\_tmp}$" src="compute_pi_eq17434611677610221202-Rescaled.png" style="width: 64.8px; height: auto;"/></span><script type="math/tex">\texttt{list\_1\_tmp}</script> contains the positions of the nonzero elements of all the multi-indices <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script> in column <span class="MathJax_Preview"><img alt="$j$" src="compute_pi_eq06791872479074567463-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">j</script>. Then each column is replicated by the amount of combinations that fulfill both condition 1 and condition 2, which is given by <span class="MathJax_Preview"><img alt="$\texttt{sum(Cond,1)}$" src="compute_pi_eq02183212726601768200-Rescaled.png" style="width: 74.39999999999999px; height: auto;"/></span><script type="math/tex">\texttt{sum(Cond,1)}</script>, since <span class="MathJax_Preview"><img alt="$\texttt{Cond}$" src="compute_pi_eq15599898037691220959-Rescaled.png" style="width: 28.799999999999997px; height: auto;"/></span><script type="math/tex">\texttt{Cond}</script> contains in column <span class="MathJax_Preview"><img alt="$j$" src="compute_pi_eq06791872479074567463-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">j</script> and row <span class="MathJax_Preview"><img alt="$r$" src="compute_pi_eq03659017738081218615-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">r</script> logical indices that indicate wheter combination <span class="MathJax_Preview"><img alt="$r$" src="compute_pi_eq03659017738081218615-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">r</script> fulfills both conditions for <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script>. That is then reshaped, such that the entry <span class="MathJax_Preview"><img alt="$u$" src="compute_pi_eq15012583454694319273-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">u</script> in <span class="MathJax_Preview"><img alt="$\texttt{list\_1}$" src="compute_pi_eq06206409333325990859-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{list\_1}</script> contains the index <span class="MathJax_Preview"><img alt="$q$" src="compute_pi_eq08880433698436706605-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">q</script> of the composition coefficient <span class="MathJax_Preview"><img alt="$H_{q,.,.}$" src="compute_pi_eq13489516383681953467-Rescaled.png" style="width: 25.2px; height: auto;"/></span><script type="math/tex">H_{q,.,.}</script> that the multi-index in position <span class="MathJax_Preview"><img alt="$u$" src="compute_pi_eq15012583454694319273-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">u</script> in <span class="MathJax_Preview"><img alt="$\texttt{h\_i}$" src="compute_pi_eq12776834098194855038-Rescaled.png" style="width: 18.0px; height: auto;"/></span><script type="math/tex">\texttt{h\_i}</script> corresponds to.</p><pre class="codeinput">        <span class="comment">%contains the row index for all of the valid combos for</span>
        <span class="comment">%all ms in the same ordering as in HV</span>
        list_1_tmp = reshape(n_idx_row,sz_un(i),[]);
        list_1     = reshape(repelem(list_1_tmp,1,sum(Cond,1)),1,[] );
        </pre><p>The same thing is done for the entries (not the positions) of all the multi-indices <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script>. The entry <span class="MathJax_Preview"><img alt="$u$" src="compute_pi_eq15012583454694319273-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">u</script> in <span class="MathJax_Preview"><img alt="$\texttt{list\_2}$" src="compute_pi_eq01110262555903670218-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{list\_2}</script> contains the value <span class="MathJax_Preview"><img alt="$m_q$" src="compute_pi_eq02145533978440193834-Rescaled.png" style="width: 15.6px; height: auto;"/></span><script type="math/tex">m_q</script> of the composition coefficient <span class="MathJax_Preview"><img alt="$H_{.,m_q,.}$" src="compute_pi_eq06294768395891210805-Rescaled.png" style="width: 32.4px; height: auto;"/></span><script type="math/tex">H_{.,m_q,.}</script> that the multi-index in position <span class="MathJax_Preview"><img alt="$u$" src="compute_pi_eq15012583454694319273-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">u</script> in <span class="MathJax_Preview"><img alt="$\texttt{h\_i}$" src="compute_pi_eq12776834098194855038-Rescaled.png" style="width: 18.0px; height: auto;"/></span><script type="math/tex">\texttt{h\_i}</script> corresponds to.</p><pre class="codeinput">        <span class="comment">%contains the entries of m for the valid combos for</span>
        <span class="comment">%all ms in the same ordering as in HV</span>
        list_2_tmp = reshape(n_idx_pos,sz_un(i),[]);
        list_2     = reshape(repelem(list_2_tmp,1,sum(Cond,1)),1,[]);
        </pre><p>What is left now is to multiply and add the indices accordingly to get the right force contribution. Firstly all the composition coefficients are ready out into <span class="MathJax_Preview"><img alt="$\texttt{pi\_dum}$" src="compute_pi_eq01709075510635064329-Rescaled.png" style="width: 39.6px; height: auto;"/></span><script type="math/tex">\texttt{pi\_dum}</script>.</p><pre class="codeinput">        pi_dum  = ones(size(h_i,2),1);
        run_ord = 1;

        <span class="keyword">for</span> ord = h_i_abs_un
        </pre><p>The logical index <span class="MathJax_Preview"><img alt="$\texttt{idx\_dum}$" src="compute_pi_eq13130319884553384936-Rescaled.png" style="width: 46.8px; height: auto;"/></span><script type="math/tex">\texttt{idx\_dum}</script> contains the positions of all multi-indices in <span class="MathJax_Preview"><img alt="$\texttt{h\_i}$" src="compute_pi_eq12776834098194855038-Rescaled.png" style="width: 18.0px; height: auto;"/></span><script type="math/tex">\texttt{h\_i}</script> that have order <span class="MathJax_Preview"><img alt="$\texttt{ord}$" src="compute_pi_eq14418500408339030549-Rescaled.png" style="width: 20.4px; height: auto;"/></span><script type="math/tex">\texttt{ord}</script>. The explicit positions of them are stored in <span class="MathJax_Preview"><img alt="$\texttt{I\_ord\_pos}$" src="compute_pi_eq13909850032285033878-Rescaled.png" style="width: 57.599999999999994px; height: auto;"/></span><script type="math/tex">\texttt{I\_ord\_pos}</script>.</p><pre class="codeinput">            idx_dum = 1:size(h_i_abs_ic.',2);
            idx_dum = idx_dum(h_i_abs_ic.' == run_ord);
            idx_dum = (h_i_ic == idx_dum);
            idx_dum = sum(idx_dum,2);
            I_ord =  logical(idx_dum);
        </pre><p>The values corresponding to those multi_indices of order <span class="MathJax_Preview"><img alt="$\texttt{ord}$" src="compute_pi_eq14418500408339030549-Rescaled.png" style="width: 20.4px; height: auto;"/></span><script type="math/tex">\texttt{ord}</script> are read out of the arrays that specify the position of the composition coefficients for each of the multi-indices, being the phase space direction they correspond to, the multi-index subindex in the reverse lexicographically ordered set they have and the multi-index entry of the multi-index <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script> they correspond to.</p><pre class="codeinput">            I_1   = list_1(I_ord);
            I_2   = h_i_idx(I_ord);
            I_3   = list_2(I_ord);
        </pre><p>In order to make use of the symmetry of the SSM-coefficients, all the multi-indices that in conjugate ordering have subindex bigger than the conjugate center index are changed to their conjugate counterpart, and for them then conjugate composition coefficients corresponding to this conjugate multi-index are read out.</p><pre class="codeinput">            z_ord = nchoosek(ord+l-1,l-1);

            <span class="comment">%split in the two index parts about conjugate</span>
            <span class="comment">%center index at order ord</span>

            lin_idx  = sub2ind([N,z_ord,ord],I_1,I_2,I_3);
            pi_dum(I_ord) =  field.H{ord}(lin_idx);


            run_ord = run_ord +1;
        </pre><pre class="codeinput">        <span class="keyword">end</span>
        </pre><p>The following step multiplies all composition coefficients that correspond to one combination of multi-indices fulfilling condition 1 and 2.</p><pre class="codeinput">        <span class="comment">%multiplication</span>
        pi_dum = prod(reshape(pi_dum, sz_un(i),[]),1);
        </pre><p>Next all the values of <span class="MathJax_Preview"><img alt="$\texttt{pi\_dum}$" src="compute_pi_eq01709075510635064329-Rescaled.png" style="width: 39.6px; height: auto;"/></span><script type="math/tex">\texttt{pi\_dum}</script> corresponding to the same multi-index <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script> have to be added. This is done by creating an array <span class="MathJax_Preview"><img alt="$\texttt{list\_3}$" src="compute_pi_eq12118154613620401445-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{list\_3}</script> that contains for each entry in <span class="MathJax_Preview"><img alt="$\texttt{pi\_dum}$" src="compute_pi_eq01709075510635064329-Rescaled.png" style="width: 39.6px; height: auto;"/></span><script type="math/tex">\texttt{pi\_dum}</script> the index <span class="MathJax_Preview"><img alt="$j$" src="compute_pi_eq06791872479074567463-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">j</script> of the size <span class="MathJax_Preview"><img alt="$2n$" src="compute_pi_eq04129684908155159413-Rescaled.png" style="width: 14.399999999999999px; height: auto;"/></span><script type="math/tex">2n</script> multi-index it corresponds to. Using <span class="MathJax_Preview"><img alt="$\texttt{accumarray}$" src="compute_pi_eq17999663193777978825-Rescaled.png" style="width: 68.39999999999999px; height: auto;"/></span><script type="math/tex">\texttt{accumarray}</script> the values that correspond to the same index <span class="MathJax_Preview"><img alt="$j$" src="compute_pi_eq06791872479074567463-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">j</script> are added up and then stored in the array <span class="MathJax_Preview"><img alt="$\texttt{pi}$" src="compute_pi_eq17686202932392897770-Rescaled.png" style="width: 13.2px; height: auto;"/></span><script type="math/tex">\texttt{pi}</script> that contains all the composition terms.</p><pre class="codeinput">        <span class="comment">%sum over combos and put into position</span>

        list_3 = repelem([1:sumidx].',sum(Cond,1));

        <span class="comment">% Indices to read out the contributions into correct position</span>
        n_contrib = sum(Cond,1)&gt;0;
        idx_pos   = find(idx);

        accum_pi  = accumarray(reshape(list_3,[],1),pi_dum);
        pis(idx_pos(n_contrib),f) = accum_pi(find(n_contrib));
        </pre><pre class="codeinput">    <span class="keyword">end</span>
<span class="keyword">end</span>
        </pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> [pis] = pink_conj(F_multi,K,field)
        </pre><pre class="codeinput"><span class="comment">% Conjugate center index at all orders, for</span>
<span class="comment">% imaginary system this is empty since then no symmetry is</span>
<span class="comment">% inherent and we only need the number of multi-indices that</span>
<span class="comment">% exist at order k, given by nchoosek(k+l-1,l-1)</span>
k           = sum(K(:,1),1);    <span class="comment">% Order of computation</span>
Z_cci       = field.Z_cci;
z_k         = Z_cci(k);
l           = size(K,1);        <span class="comment">% SSM dimension</span>
<span class="comment">% Phase space dimension</span>
N           = field.N;

<span class="comment">% if system is not real, then full set of order k multi-indices in reverse lex. ordering</span>
revlex2conj = field.revlex2conj;   <span class="comment">% Set to convert indices from rev. lex. to conjugate ordering</span>

<span class="comment">% nonzero entries in the multi-index array</span>
F_multi_pos   = (F_multi ~= 0);
sz          = size(F_multi,2);
col_pos     = 1:sz;
        </pre><p>Initialise space for the <span class="MathJax_Preview"><img alt="$\pi_{\mathbf{m},\mathbf{k}_f}$" src="compute_pi_eq02458074943802699371-Rescaled.png" style="width: 28.799999999999997px; height: auto;"/></span><script type="math/tex">\pi_{\mathbf{m},\mathbf{k}_f}</script>.</p><pre class="codeinput">pis = zeros(size(col_pos,2),z_k);
        </pre><p>The array <span class="MathJax_Preview"><img alt="$\texttt{sz\_pos}$" src="compute_pi_eq07307310309999988163-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_pos}</script> is a row vector containing in each row the number of nonzero entries of the multi-index the row corresponds to. This is useful, since <span class="MathJax_Preview"><img alt="$H_{i,0,\mathbf{h}} = 0$" src="compute_pi_eq06950165298109173078-Rescaled.png" style="width: 55.199999999999996px; height: auto;"/></span><script type="math/tex">H_{i,0,\mathbf{h}} = 0</script> for any nonzero <span class="MathJax_Preview"><img alt="$\mathbf{h}$" src="compute_pi_eq13551287546431487114-Rescaled.png" style="width: 8.4px; height: auto;"/></span><script type="math/tex">\mathbf{h}</script>. Therefore for each <span class="MathJax_Preview"><img alt="$\mathbf{m}$" src="compute_pi_eq03598573572044437231-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{m}</script> in <span class="MathJax_Preview"><img alt="$\texttt{F\_multi}$" src="compute_pi_eq18041254262223804567-Rescaled.png" style="width: 45.6px; height: auto;"/></span><script type="math/tex">\texttt{F\_multi}</script> we only have to find the composition coefficients corresponding to the nonzero entries of <span class="MathJax_Preview"><img alt="$\mathbf{m}$" src="compute_pi_eq03598573572044437231-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{m}</script>. Furthermore then condition 1 looks like <span class="MathJax_Preview"><img alt="$\sum_{v,m_v \neq 0} \mathbf{h}_v = \mathbf{k}_f$" src="compute_pi_eq14018137582768259288-Rescaled.png" style="width: 92.39999999999999px; height: auto;"/></span><script type="math/tex">\sum_{v,m_v \neq 0} \mathbf{h}_v = \mathbf{k}_f</script>. For each <span class="MathJax_Preview"><img alt="$f$" src="compute_pi_eq02527148203711597490-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">f</script> and <span class="MathJax_Preview"><img alt="$\mathbf{m}$" src="compute_pi_eq03598573572044437231-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{m}</script> all such combinations have to be found.</p><pre class="codeinput">sz_pos   = sum(F_multi_pos,1);
        </pre><p>This function computes all those combinations for all order <span class="MathJax_Preview"><img alt="$m$" src="compute_pi_eq18216620034067401164-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">m</script> multi-indices <span class="MathJax_Preview"><img alt="$\mathbf{m}$" src="compute_pi_eq03598573572044437231-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{m}</script> and all <span class="MathJax_Preview"><img alt="$f$" src="compute_pi_eq02527148203711597490-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">f</script>. It does so by considering unique numbers in <span class="MathJax_Preview"><img alt="$\texttt{sz\_pos}$" src="compute_pi_eq07307310309999988163-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_pos}</script> and using them as the number of multi-indices <span class="MathJax_Preview"><img alt="$\mathbf{h}_i$" src="compute_pi_eq04515425204478813704-Rescaled.png" style="width: 10.799999999999999px; height: auto;"/></span><script type="math/tex">\mathbf{h}_i</script> that have to sum up to <span class="MathJax_Preview"><img alt="$\mathbf{k}_f$" src="compute_pi_eq12788223238356508156-Rescaled.png" style="width: 14.399999999999999px; height: auto;"/></span><script type="math/tex">\mathbf{k}_f</script> for all <span class="MathJax_Preview"><img alt="$f$" src="compute_pi_eq02527148203711597490-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">f</script>.</p><p><span class="MathJax_Preview"><img alt="$\texttt{h}$" src="compute_pi_eq13958417881461454476-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">\texttt{h}</script> is a cell array, that contains in its first dimension the combinations for all <span class="MathJax_Preview"><img alt="$f$" src="compute_pi_eq02527148203711597490-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">f</script> and its second dimension corresponds to unique numbers in <span class="MathJax_Preview"><img alt="$\texttt{sz\_pos}$" src="compute_pi_eq07307310309999988163-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_pos}</script>. They are stored in <span class="MathJax_Preview"><img alt="$\texttt{sz\_un}$" src="compute_pi_eq01051170770119728142-Rescaled.png" style="width: 32.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un}</script>. For each entry in <span class="MathJax_Preview"><img alt="$\texttt{sz\_pos}$" src="compute_pi_eq07307310309999988163-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_pos}</script> the corresponding entry in <span class="MathJax_Preview"><img alt="$\texttt{sz\_un\_ic}$" src="compute_pi_eq14055223087504850512-Rescaled.png" style="width: 50.4px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un\_ic}</script> gives the column that it corresponds to in <span class="MathJax_Preview"><img alt="$\texttt{h}$" src="compute_pi_eq13958417881461454476-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">\texttt{h}</script>.</p><p><span class="MathJax_Preview"><img alt="$\texttt{h\{f,i\}}$" src="compute_pi_eq06440395696489239162-Rescaled.png" style="width: 40.8px; height: auto;"/></span><script type="math/tex">\texttt{h\{f,i\}}</script> contains a 3 dimensional array. The first dimension has size <span class="MathJax_Preview"><img alt="$l$" src="compute_pi_eq17216086743898025322-Rescaled.png" style="width: 3.5999999999999996px; height: auto;"/></span><script type="math/tex">l</script>, the second hase size <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script>. Its third dimension has size <span class="MathJax_Preview"><img alt="$\texttt{combnos(i)}$" src="compute_pi_eq05682266413850064750-Rescaled.png" style="width: 67.2px; height: auto;"/></span><script type="math/tex">\texttt{combnos(i)}</script>.</p><p>This array contains in every matrix a set <span class="MathJax_Preview"><img alt="$\{\mathbf{h}_{v}\}_{v}$" src="compute_pi_eq16573582683439618002-Rescaled.png" style="width: 31.2px; height: auto;"/></span><script type="math/tex">\{\mathbf{h}_{v}\}_{v}</script> that fulfills condition 1 for <span class="MathJax_Preview"><img alt="$\mathbf{k}_f$" src="compute_pi_eq12788223238356508156-Rescaled.png" style="width: 14.399999999999999px; height: auto;"/></span><script type="math/tex">\mathbf{k}_f</script> that is stored in <span class="MathJax_Preview"><img alt="$\texttt{K2(:,f)}$" src="compute_pi_eq13807961323307379716-Rescaled.png" style="width: 46.8px; height: auto;"/></span><script type="math/tex">\texttt{K2(:,f)}</script>. Each set consists of <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> elements.</p><p><span class="MathJax_Preview"><img alt="$\texttt{combnos}$" src="compute_pi_eq10923592312068766590-Rescaled.png" style="width: 48.0px; height: auto;"/></span><script type="math/tex">\texttt{combnos}</script> contains the amount of combinations that exist for every tuple <span class="MathJax_Preview"><img alt="$(\texttt{f,i})$" src="compute_pi_eq06605613369182313080-Rescaled.png" style="width: 28.799999999999997px; height: auto;"/></span><script type="math/tex">(\texttt{f,i})</script>.</p><pre class="codeinput">[h, combnos,sz_un,sz_un_ic] = multi_<a href="../../../Library/Features/misc/nsumk.html">nsumk</a>(sz_pos,K);

<span class="comment">%stores the order of all the multi-indices in h</span>
h_abs = cellfun(@(x) reshape(sum(x,1),size(x,2),[]), h, <span class="string">'UniformOutput'</span>,false);

<span class="comment">%loop over all the order k multi-indices with index below center</span>
<span class="comment">%index in conjugate ordering</span>
<span class="keyword">for</span> f = 1:z_k

    <span class="comment">%loop over unique amounts of nonzero entries in the</span>
    <span class="comment">%multi-indices m</span>
    <span class="keyword">for</span> i = 1:size(sz_un,2)
        </pre><pre class="codeinput">        <span class="comment">%position of multi-indices in F_multi that have sz_un(i) nonzero entries</span>
        idx    = sz_un_ic == i;

        <span class="comment">%number of multi-indices in F_multi that have i nonzero entries</span>
        sumidx = sum(idx);

        <span class="comment">%columns of Fm that contain i nonzero elements</span>
        Fm_idx         = F_multi(:,idx.');
        Fm_idx_find    = find(Fm_idx);
        [Fm_idx_row,~] = ind2sub(size(Fm_idx),Fm_idx_find);
        </pre><p><span class="MathJax_Preview"><img alt="$\texttt{Fm\_idx\_pos}$" src="compute_pi_eq13441206244026983017-Rescaled.png" style="width: 66.0px; height: auto;"/></span><script type="math/tex">\texttt{Fm\_idx\_pos}</script> contains the entries of <span class="MathJax_Preview"><img alt="$\texttt{F\_multi}$" src="compute_pi_eq18041254262223804567-Rescaled.png" style="width: 45.6px; height: auto;"/></span><script type="math/tex">\texttt{F\_multi}</script> that correspond to the multi-indices that have <span class="MathJax_Preview"><img alt="$i$" src="compute_pi_eq08984912804010224726-Rescaled.png" style="width: 4.8px; height: auto;"/></span><script type="math/tex">i</script> nonzero elements. It is therefore a  <span class="MathJax_Preview"><img alt="$\texttt{sumidx *sz\_un(i)}$" src="compute_pi_eq18077958322521653699-Rescaled.png" style="width: 106.8px; height: auto;"/></span><script type="math/tex">\texttt{sumidx *sz\_un(i)}</script> by 1 array.</p><pre class="codeinput">        Fm_idx_pos     = Fm_idx(Fm_idx_find);
        </pre><p>This step checks where condition 2 is fulfilled. <span class="MathJax_Preview"><img alt="$\texttt{h\_abs\{f,i\}}$" src="compute_pi_eq10750961844098868105-Rescaled.png" style="width: 67.2px; height: auto;"/></span><script type="math/tex">\texttt{h\_abs\{f,i\}}</script> contains a <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> by <span class="MathJax_Preview"><img alt="$\texttt{combnos(i)}$" src="compute_pi_eq05682266413850064750-Rescaled.png" style="width: 67.2px; height: auto;"/></span><script type="math/tex">\texttt{combnos(i)}</script> dimensionaly array. In every column it contains the absolute values of all multi_indices of one combination <span class="MathJax_Preview"><img alt="$\{\mathbf{h}_v\}_v$" src="compute_pi_eq09845584587950433315-Rescaled.png" style="width: 31.2px; height: auto;"/></span><script type="math/tex">\{\mathbf{h}_v\}_v</script> that fulfills condition 1 for <span class="MathJax_Preview"><img alt="$\texttt{f}$" src="compute_pi_eq06745379350049732521-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">\texttt{f}</script> and contains <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> elements. Condition 2 is checked simultaneously for all <span class="MathJax_Preview"><img alt="$\mathbf{m}$" src="compute_pi_eq03598573572044437231-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{m}</script> of order <span class="MathJax_Preview"><img alt="$\texttt{order}$" src="compute_pi_eq15072695448156311974-Rescaled.png" style="width: 33.6px; height: auto;"/></span><script type="math/tex">\texttt{order}</script> that contain <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> nonzero entries.</p><p><span class="MathJax_Preview"><img alt="$$\texttt{h\_abs\{f,i\}} = \pmatrix{ \mathbf{h_1^1} &amp; \cdots &amp; \mathbf{h_1^\texttt{combnos(i)}}\cr
\mathbf{h_2^1} &amp; \cdots &amp; \mathbf{h_2^\texttt{combnos(i)}}\cr \vdots &amp; \cdots
&amp; \vdots\cr \mathbf{h_{\texttt{sz\_un(i)}}^1} &amp; \cdots &amp; \mathbf{h_{\texttt{sz\_un(i)}}^\texttt{combnos(i)}}}
$$" src="compute_pi_eq15361356171136157777-Rescaled.png" style="width: 290.4px; height: auto;"/></span><script type="math/tex">\texttt{h\_abs\{f,i\}} = \pmatrix{ \mathbf{h_1^1} & \cdots & \mathbf{h_1^\texttt{combnos(i)}}\cr
\mathbf{h_2^1} & \cdots & \mathbf{h_2^\texttt{combnos(i)}}\cr \vdots & \cdots
& \vdots\cr \mathbf{h_{\texttt{sz\_un(i)}}^1} & \cdots & \mathbf{h_{\texttt{sz\_un(i)}}^\texttt{combnos(i)}}}
</script></p><p>And therefore if the size <span class="MathJax_Preview"><img alt="$2n$" src="compute_pi_eq04129684908155159413-Rescaled.png" style="width: 14.399999999999999px; height: auto;"/></span><script type="math/tex">2n</script> multi indices that have <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> nonzero elements are <span class="MathJax_Preview"><img alt="$\mathbf{m}_1, ... , \mathbf{m}_\texttt{sumidx}$" src="compute_pi_eq18197536538755691665-Rescaled.png" style="width: 94.8px; height: auto;"/></span><script type="math/tex">\mathbf{m}_1, ... , \mathbf{m}_\texttt{sumidx}</script>, and we define <span class="MathJax_Preview"><img alt="$\mathbf{m}_1^+$" src="compute_pi_eq17098975814225806447-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_1^+</script> as the size <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> multi-index containing the nonzero elements of <span class="MathJax_Preview"><img alt="$\mathbf{m}_1$" src="compute_pi_eq01085214355710257986-Rescaled.png" style="width: 16.8px; height: auto;"/></span><script type="math/tex">\mathbf{m}_1</script>,then condition 2 is checked as follows:</p><p><span class="MathJax_Preview"><img alt="$$\texttt{Cond\_dum} = \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_1^+\cr\texttt{h\_abs\{f,i\}}
==  \mathbf{m}_2^+ \cr \vdots \cr\texttt{h\_abs\{f,i\}}==
\mathbf{m}_\texttt{sumidx}^+} \in \mathbf{N} \textrm{mod 2}^{\texttt{sumidx} \times \texttt{combnos(i)}}$$" src="compute_pi_eq14346524362400841325-Rescaled.png" style="width: 428.4px; height: auto;"/></span><script type="math/tex">\texttt{Cond\_dum} = \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_1^+\cr\texttt{h\_abs\{f,i\}}
==  \mathbf{m}_2^+ \cr \vdots \cr\texttt{h\_abs\{f,i\}}==
\mathbf{m}_\texttt{sumidx}^+} \in \mathbf{N} \textrm{mod 2}^{\texttt{sumidx} \times \texttt{combnos(i)}}</script></p><pre class="codeinput">        Cond_dum = repmat(h_abs{f,i},sumidx,1) &gt;= full(Fm_idx_pos);
        </pre><p>Now we would like to check which combinations fulfill condition 2 for all of their elements. This corresponds to columns of <span class="MathJax_Preview"><img alt="$\texttt{h\_abs\{f,i\}} == \mathbf{m}_j^+$" src="compute_pi_eq12047648062529164767-Rescaled.png" style="width: 114.0px; height: auto;"/></span><script type="math/tex">\texttt{h\_abs\{f,i\}} == \mathbf{m}_j^+</script> where all elements are one. So summing over the rows only the columns that have <span class="MathJax_Preview"><img alt="$\texttt{sz\_un(i)}$" src="compute_pi_eq07272003681592212572-Rescaled.png" style="width: 51.6px; height: auto;"/></span><script type="math/tex">\texttt{sz\_un(i)}</script> as their entry correspond to valid combinations that fulfill condition 2 to for <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script>, and this has to be done for <span class="MathJax_Preview"><img alt="$j = 1,...,\texttt{sumidx}$" src="compute_pi_eq08307348901538058802-Rescaled.png" style="width: 94.8px; height: auto;"/></span><script type="math/tex">j = 1,...,\texttt{sumidx}</script>.</p><p>To do this we transpose <span class="MathJax_Preview"><img alt="$\texttt{Cond\_dum}$" src="compute_pi_eq04341677538977575504-Rescaled.png" style="width: 54.0px; height: auto;"/></span><script type="math/tex">\texttt{Cond\_dum}</script> and permute the first two dimensions. Furthermore, now a third dimension is added which each corresponds to one <span class="MathJax_Preview"><img alt="$\mathbf{m}_i^+$" src="compute_pi_eq13217126165152531061-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_i^+</script>.</p><pre class="codeinput">        <span class="comment">%reshape, such that every slice of 3rd dim corresponds to</span>
        <span class="comment">%conditions for one m, first dimension</span>
        Cond_dum = reshape(Cond_dum.',[],sz_un(i),sumidx);
        <span class="comment">%permute, every column now contains conds for one combo of</span>
        <span class="comment">%h_is, sum all those cond values, if they are all one in a</span>
        <span class="comment">%column, they contribute.</span>
        Cond_dum =  sum(permute( Cond_dum,[2,1,3]),1);
        </pre><p>Now a slice of the third dimension looks like <span class="MathJax_Preview"><img alt="$\texttt{Cond\_dum(:,:,j)} = \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_j^+} $. The sum over the rows reveals which combos contribute. The resulting vector is recast, such that every column corresponds to one $\mathbf{m}_j^+$" src="compute_pi_eq18295123890301697593-Rescaled.png" style="width: 1040.3999999999999px; height: auto;"/></span><script type="math/tex">\texttt{Cond\_dum(:,:,j)} = \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_j^+} $. The sum over the rows reveals which combos contribute. The resulting vector is recast, such that every column corresponds to one $\mathbf{m}_j^+</script> and the rows correspond to the combinations that fulfill condition 1. The ones that also fulfill condition 2 are logical ones, the others are zero.</p><pre class="codeinput">        <span class="comment">%check if every vector of a combo fulfills cond, if not</span>
        <span class="comment">%discard it</span>
        Cond     = reshape(Cond_dum == full(sz_un(i)),combnos(f,i),[] );
        <span class="keyword">if</span> nnz(Cond) == 0
            <span class="keyword">continue</span>
        <span class="keyword">end</span>
        </pre><p>The array indices reads out the index of the valid combinations. Specifically if the different combinations are numbered with numbers 1 to <span class="MathJax_Preview"><img alt="$\texttt{combnos(f,i)}$" src="compute_pi_eq06000355065613730742-Rescaled.png" style="width: 80.39999999999999px; height: auto;"/></span><script type="math/tex">\texttt{combnos(f,i)}</script>, then it assigns every valid combination the number it corresponds to.</p><pre class="codeinput">        <span class="comment">%contains indices to read out the ones fulfilling cond2</span>
        <span class="comment">%from h</span>
        indices  = repmat([1:combnos(f,i)].',1,sumidx);
        Cond_ind = indices(Cond);
        </pre><p>Consequently all valid combinations of multi-indices are explicitly read out into a array that contains all of the multi-indices in its second dimension. All valid combinations for <span class="MathJax_Preview"><img alt="$\mathbf{m}_1^+$" src="compute_pi_eq17098975814225806447-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_1^+</script> are in it as a sequence, followed by all valid combinations for <span class="MathJax_Preview"><img alt="$\mathbf{m}_2^+$" src="compute_pi_eq02359984336574730220-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_2^+</script> and so forth.</p><pre class="codeinput">        <span class="comment">%All combos in first dim. each combo has nns(ind)</span>
        <span class="comment">%contributions - to get back, reshape to l, nns(ind), []</span>
        h_i      = reshape( h{f,i}(:,:,reshape(Cond_ind,[],1)) ,l,[]);
        </pre><p>In order to read out the composition coefficients corresponding to all those multi-indices we have to know their position in a set of reverse lexicographical ordering of all multi-indices of their respective order and size. In order to do this efficient, unique multi-indices are extracted from <span class="MathJax_Preview"><img alt="$\texttt{h\_i}$" src="compute_pi_eq12776834098194855038-Rescaled.png" style="width: 18.0px; height: auto;"/></span><script type="math/tex">\texttt{h\_i}</script>, and their position is calculated, in either conjugate ordering (real system) or in reverse lex. ordering (non real system). Then the subindices of all multi-indices are stored in the array <span class="MathJax_Preview"><img alt="$\texttt{h\_i\_multi}$" src="compute_pi_eq08109281396480677099-Rescaled.png" style="width: 57.599999999999994px; height: auto;"/></span><script type="math/tex">\texttt{h\_i\_multi}</script>.</p><pre class="codeinput">        [h_i_un,~,h_i_ic] = unique(h_i.',<span class="string">'rows'</span>);
        h_i_idx_temp    = <a href="../../../Library/Manifold/private/multi_index_2_ordering.html">multi_index_2_ordering</a>(h_i_un.',field.ordering,revlex2conj);
        h_i_idx         = h_i_idx_temp(h_i_ic.');
        </pre><p>To read out the composition coefficients at the right order the absolute values of the multi-indices also has to be known. They are stored in <span class="MathJax_Preview"><img alt="$\texttt{h\_i\_abs}$" src="compute_pi_eq07944577750347267428-Rescaled.png" style="width: 44.4px; height: auto;"/></span><script type="math/tex">\texttt{h\_i\_abs}</script>.</p><pre class="codeinput">        h_i_abs    = sum(h_i_un.');
        [h_i_abs_un,~,h_i_abs_ic] = unique(h_i_abs);
        </pre><p><span class="MathJax_Preview"><img alt="$\texttt{list\_1\_tmp}$" src="compute_pi_eq17434611677610221202-Rescaled.png" style="width: 64.8px; height: auto;"/></span><script type="math/tex">\texttt{list\_1\_tmp}</script> contains the positions of the nonzero elements of all the multi-indices <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script> in column <span class="MathJax_Preview"><img alt="$j$" src="compute_pi_eq06791872479074567463-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">j</script>. Then each column is replicated by the amount of combinations that fulfill both condition 1 and condition 2, which is given by <span class="MathJax_Preview"><img alt="$\texttt{sum(Cond,1)}$" src="compute_pi_eq02183212726601768200-Rescaled.png" style="width: 74.39999999999999px; height: auto;"/></span><script type="math/tex">\texttt{sum(Cond,1)}</script>, since <span class="MathJax_Preview"><img alt="$\texttt{Cond}$" src="compute_pi_eq15599898037691220959-Rescaled.png" style="width: 28.799999999999997px; height: auto;"/></span><script type="math/tex">\texttt{Cond}</script> contains in column <span class="MathJax_Preview"><img alt="$j$" src="compute_pi_eq06791872479074567463-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">j</script> and row <span class="MathJax_Preview"><img alt="$r$" src="compute_pi_eq03659017738081218615-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">r</script> logical indices that indicate wheter combination <span class="MathJax_Preview"><img alt="$r$" src="compute_pi_eq03659017738081218615-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">r</script> fulfills both conditions for <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script>. That is then reshaped, such that the entry <span class="MathJax_Preview"><img alt="$u$" src="compute_pi_eq15012583454694319273-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">u</script> in <span class="MathJax_Preview"><img alt="$\texttt{list\_1}$" src="compute_pi_eq06206409333325990859-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{list\_1}</script> contains the index <span class="MathJax_Preview"><img alt="$q$" src="compute_pi_eq08880433698436706605-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">q</script> of the composition coefficient <span class="MathJax_Preview"><img alt="$H_{q,.,.}$" src="compute_pi_eq13489516383681953467-Rescaled.png" style="width: 25.2px; height: auto;"/></span><script type="math/tex">H_{q,.,.}</script> that the multi-index in position <span class="MathJax_Preview"><img alt="$u$" src="compute_pi_eq15012583454694319273-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">u</script> in <span class="MathJax_Preview"><img alt="$\texttt{h\_i}$" src="compute_pi_eq12776834098194855038-Rescaled.png" style="width: 18.0px; height: auto;"/></span><script type="math/tex">\texttt{h\_i}</script> corresponds to.</p><pre class="codeinput">        <span class="comment">%contains the row index for all of the valid combos for</span>
        <span class="comment">%all ms in the same ordering as in HV</span>
        list_1_tmp = reshape(Fm_idx_row,sz_un(i),[]);
        list_1     = reshape(repelem(list_1_tmp,1,sum(Cond,1)),1,[] );
        </pre><p>The same thing is done for the entries (not the positions) of all the multi-indices <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script>. The entry <span class="MathJax_Preview"><img alt="$u$" src="compute_pi_eq15012583454694319273-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">u</script> in <span class="MathJax_Preview"><img alt="$\texttt{list\_2}$" src="compute_pi_eq01110262555903670218-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{list\_2}</script> contains the value <span class="MathJax_Preview"><img alt="$m_q$" src="compute_pi_eq02145533978440193834-Rescaled.png" style="width: 15.6px; height: auto;"/></span><script type="math/tex">m_q</script> of the composition coefficient <span class="MathJax_Preview"><img alt="$H_{.,m_q,.}$" src="compute_pi_eq06294768395891210805-Rescaled.png" style="width: 32.4px; height: auto;"/></span><script type="math/tex">H_{.,m_q,.}</script> that the multi-index in position <span class="MathJax_Preview"><img alt="$u$" src="compute_pi_eq15012583454694319273-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">u</script> in <span class="MathJax_Preview"><img alt="$\texttt{h\_i}$" src="compute_pi_eq12776834098194855038-Rescaled.png" style="width: 18.0px; height: auto;"/></span><script type="math/tex">\texttt{h\_i}</script> corresponds to.</p><pre class="codeinput">        <span class="comment">%contains the entries of m for the valid combos for</span>
        <span class="comment">%all ms in the same ordering as in HV</span>
        list_2_tmp = reshape(Fm_idx_pos,sz_un(i),[]);
        list_2     = reshape(repelem(list_2_tmp,1,sum(Cond,1)),1,[]);
        </pre><p>What is left now is to multiply and add the indices accordingly to get the right force contribution. Firstly all the composition coefficients are ready out into <span class="MathJax_Preview"><img alt="$\texttt{pi\_dum}$" src="compute_pi_eq01709075510635064329-Rescaled.png" style="width: 39.6px; height: auto;"/></span><script type="math/tex">\texttt{pi\_dum}</script>.</p><pre class="codeinput">        pi_dum  = ones(size(h_i,2),1);
        run_ord = 1;
        <span class="keyword">for</span> ord = h_i_abs_un
        </pre><p>The logical index <span class="MathJax_Preview"><img alt="$\texttt{idx\_dum}$" src="compute_pi_eq13130319884553384936-Rescaled.png" style="width: 46.8px; height: auto;"/></span><script type="math/tex">\texttt{idx\_dum}</script> contains the positions of all multi-indices in <span class="MathJax_Preview"><img alt="$\texttt{h\_i}$" src="compute_pi_eq12776834098194855038-Rescaled.png" style="width: 18.0px; height: auto;"/></span><script type="math/tex">\texttt{h\_i}</script> that have order <span class="MathJax_Preview"><img alt="$\texttt{ord}$" src="compute_pi_eq14418500408339030549-Rescaled.png" style="width: 20.4px; height: auto;"/></span><script type="math/tex">\texttt{ord}</script>. The explicit positions of them are stored in <span class="MathJax_Preview"><img alt="$\texttt{I\_ord\_pos}$" src="compute_pi_eq13909850032285033878-Rescaled.png" style="width: 57.599999999999994px; height: auto;"/></span><script type="math/tex">\texttt{I\_ord\_pos}</script>.</p><pre class="codeinput">            idx_dum = 1:size(h_i_abs_ic.',2);
            idx_dum = idx_dum(h_i_abs_ic.' == run_ord);
            idx_dum = (h_i_ic == idx_dum);
            idx_dum = sum(idx_dum,2);
            I_ord =  logical(idx_dum);
            I_ord_pos = find(I_ord);
        </pre><p>The values corresponding to those multi_indices of order <span class="MathJax_Preview"><img alt="$\texttt{ord}$" src="compute_pi_eq14418500408339030549-Rescaled.png" style="width: 20.4px; height: auto;"/></span><script type="math/tex">\texttt{ord}</script> are read out of the arrays that specify the position of the composition coefficients for each of the multi-indices, being the phase space direction they correspond to, the multi-index subindex in the reverse lexicographically ordered set they have and the multi-index entry of the multi-index <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script> they correspond to.</p><pre class="codeinput">            I_1   = list_1(I_ord);
            I_2   = h_i_idx(I_ord);
            I_3   = list_2(I_ord);
        </pre><p>In order to make use of the symmetry of the SSM-coefficients, all the multi-indices that in conjugate ordering have subindex bigger than the conjugate center index are changed to their conjugate counterpart, and for them then conjugate composition coefficients corresponding to this conjugate multi-index are read out.</p><pre class="codeinput">            z_ord = nchoosek(ord+l-1,l-1);
            z_cci_ord = Z_cci(ord);

            <span class="comment">%split in the two index parts about conjugate</span>
            <span class="comment">%center index at order ord</span>
            idx_2   = I_2 &lt;= z_cci_ord;

            lin_idx_a  = sub2ind([N,Z_cci(ord),ord],I_1(idx_2),I_2(idx_2),I_3(idx_2));
            <span class="comment">%[N,Z_cci(ord),ord],I_1(idx_2),I_2(idx_2),I_3(idx_2)</span>
            <span class="comment">%field.H{ord},(lin_idx_a)</span>

            pi_dum(I_ord_pos(idx_2)) =  field.H{ord}(lin_idx_a);

            lin_idx_b  = sub2ind([N,Z_cci(ord),ord],I_1(~idx_2),z_ord-I_2(~idx_2)+1,I_3(~idx_2));
            pi_dum(I_ord_pos(~idx_2)) = conj(field.H{ord}(lin_idx_b));


            run_ord = run_ord +1;
        </pre><pre class="codeinput">        <span class="keyword">end</span>
        </pre><p>The following step multiplies all composition coefficients that correspond to one combination of multi-indices fulfilling condition 1 and 2.</p><pre class="codeinput">        <span class="comment">%multiplication</span>
        pi_dum = prod(reshape(pi_dum, sz_un(i),[]),1);
        </pre><p>Next all the values of <span class="MathJax_Preview"><img alt="$\texttt{pi\_dum}$" src="compute_pi_eq01709075510635064329-Rescaled.png" style="width: 39.6px; height: auto;"/></span><script type="math/tex">\texttt{pi\_dum}</script> corresponding to the same multi-index <span class="MathJax_Preview"><img alt="$\mathbf{m}_j^+$" src="compute_pi_eq04393645293484888739-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{m}_j^+</script> have to be added. This is done by creating an array <span class="MathJax_Preview"><img alt="$\texttt{list\_3}$" src="compute_pi_eq12118154613620401445-Rescaled.png" style="width: 38.4px; height: auto;"/></span><script type="math/tex">\texttt{list\_3}</script> that contains for each entry in <span class="MathJax_Preview"><img alt="$\texttt{pi\_dum}$" src="compute_pi_eq01709075510635064329-Rescaled.png" style="width: 39.6px; height: auto;"/></span><script type="math/tex">\texttt{pi\_dum}</script> the index <span class="MathJax_Preview"><img alt="$j$" src="compute_pi_eq06791872479074567463-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">j</script> of the size <span class="MathJax_Preview"><img alt="$2n$" src="compute_pi_eq04129684908155159413-Rescaled.png" style="width: 14.399999999999999px; height: auto;"/></span><script type="math/tex">2n</script> multi-index it corresponds to. Using <span class="MathJax_Preview"><img alt="$\texttt{accumarray}$" src="compute_pi_eq17999663193777978825-Rescaled.png" style="width: 68.39999999999999px; height: auto;"/></span><script type="math/tex">\texttt{accumarray}</script> the values that correspond to the same index <span class="MathJax_Preview"><img alt="$j$" src="compute_pi_eq06791872479074567463-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">j</script> are added up and then stored in the array <span class="MathJax_Preview"><img alt="$\texttt{pi}$" src="compute_pi_eq17686202932392897770-Rescaled.png" style="width: 13.2px; height: auto;"/></span><script type="math/tex">\texttt{pi}</script> that contains all the composition terms.</p><pre class="codeinput">        <span class="comment">%sum over combos and put into position</span>

        list_3 = repelem([1:sumidx].',sum(Cond,1));

        <span class="comment">% Indices to read out the contributions into correct position</span>
        n_contrib = sum(Cond,1)&gt;0;
        idx_pos   = find(idx);

        accum_pi  = accumarray(reshape(list_3,[],1),pi_dum);
        pis(idx_pos(n_contrib),f) = accum_pi(find(n_contrib));
        </pre><pre class="codeinput">    <span class="keyword">end</span>
<span class="keyword">end</span>
        </pre><pre class="codeinput"><span class="keyword">end</span>
        </pre><p class="footer"><br/><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB R2023a</a><br/></p></div><!--
            ##### SOURCE BEGIN #####
            %% COMPUTE_PI
%
%%
function [pis] = compute_pi(n_mat,k_mat, field)
%% Compute composition of powers series.
% Computes pi_n_k for every combination of multi-indices in the two input
% matrices
% Multi index arrays n_mat and k_mat need to contain multi indices of same
% order |n| and |k| resepectively
% Pi are the forcing contribution coefficients resulting from composition
% with the SSM parametrisation.
%%
n_pos_idx = any(n_mat);
k_pos_idx = any(k_mat);

% No calculations for zero multi-indices needed
n_zero_idx = find(~n_pos_idx);
k_zero_idx = find(~k_pos_idx);

switch field.ordering
    case 'revlex'

        pis_pos = pink(n_mat(:,n_pos_idx),k_mat(:,k_pos_idx), field);
       
    case 'conjugate'
        %Needs all multi-indices in n_mat and k_mat to have same order
        pis_pos = pink_conj(n_mat(:,n_pos_idx),k_mat(:,k_pos_idx),field);
end
%% Read results into output array
%insert zero columns
if ~isempty(k_zero_idx)
    pis_cols = zeros(size(pis_pos,1),size(k_mat,2));
    pis_cols(:,k_pos_idx) = pis_pos;
else 
    pis_cols = pis_pos;
end

%insert zero rows
if ~isempty(n_zero_idx)
    pis = zeros(size(n_mat,2),size(k_mat,2));
    pis(n_pos_idx,:) = pis_cols;
else
    pis = pis_cols;
end
%% Special case
% fill pis with ones where k and n_mat both have a zero multiindex
for n_i = n_zero_idx
    for k_i = k_zero_idx
        pis(n_i,k_i) = 1;
    end
end
end

function [pis] = pink(n_mat,K,field)
assert(nnz(n_mat<0)==0,'Negative multiindices')

%%
% Conjugate center index at all orders, for
% imaginary system this is empty since then no symmetry is
% inherent and we only need the number of multi-indices that
% exist at order k, given by nchoosek(k+l-1,l-1)
l           = size(K,1);        % SSM dimension
z_k         = size(K,2);
% Phase space dimension
N           = size(n_mat,1);
% nonzero entries in the multi-index array
F_multi_pos   = (n_mat ~= 0);
sz          = size(n_mat,2);
col_pos     = 1:sz;
%%
% Initialise space for the $\pi_{\mathbf{m},\mathbf{k}_f}$.
pis = zeros(size(col_pos,2),z_k);

%%
% The array $\texttt{sz\_pos}$ is a row vector containing in each row the number
% of nonzero entries of the multi-index the row corresponds to. This is useful,
% since $H_{i,0,\mathbf{h}} = 0$ for any nonzero $\mathbf{h}$. Therefore for each
% $\mathbf{m}$ in $\texttt{F\_multi}$ we only have to find the composition coefficients
% corresponding to the nonzero entries of $\mathbf{m}$. Furthermore then condition
% 1 looks like $\sum_{v,m_v \neq 0} \mathbf{h}_v = \mathbf{k}_f$. For each $f$
% and $\mathbf{m}$ all such combinations have to be found.
sz_pos   = sum(F_multi_pos,1);

%%
% This function computes all those combinations for all order $m$ multi-indices
% $\mathbf{m}$ and all $f$. It does so by considering unique numbers in $\texttt{sz\_pos}$
% and using them as the number of multi-indices $\mathbf{h}_i$ that have to sum
% up to $\mathbf{k}_f$ for all $f$.
%
% $\texttt{h}$ is a cell array, that contains in its first dimension the combinations
% for all $f$ and its second dimension corresponds to unique numbers in $\texttt{sz\_pos}$.
% They are stored in $\texttt{sz\_un}$. For each entry in $\texttt{sz\_pos}$ the
% corresponding entry in $\texttt{sz\_un\_ic}$ gives the column that it corresponds
% to in $\texttt{h}$.
%
% $\texttt{h\{f,i\}}$ contains a 3 dimensional array. The first dimension has
% size $l$, the second hase size $\texttt{sz\_un(i)}$. Its third dimension has
% size $\texttt{combnos(i)}$.
%
% This array contains in every matrix a set $\{\mathbf{h}_{v}\}_{v}$ that fulfills
% condition 1 for $\mathbf{k}_f$ that is stored in $\texttt{K2(:,f)}$. Each set
% consists of $\texttt{sz\_un(i)}$ elements.
%
% $\texttt{combnos}$ contains the amount of combinations that exist for every
% tuple $(\texttt{f,i})$.
[h, combnos,sz_un,sz_un_ic] = multi_<a href="../../../Library/Features/misc/nsumk.html">nsumk</a>(sz_pos,K);
%stores the order of all the multi-indices in h
h_abs = cellfun(@(x) reshape(sum(x,1),size(x,2),[]), h, 'UniformOutput',false);

%loop over all the order k multi-indices with index below center
%index in conjugate ordering
for f = 1:z_k
    
    %loop over unique amounts of nonzero entries in the
    %multi-indices m
    for i = 1:size(sz_un,2)
        
        %position of multi-indices in F_multi that have sz_un(i) nonzero entries
        idx    = sz_un_ic == i;
        
        %number of multi-indices in F_multi that have i nonzero entries
        sumidx = sum(idx);        
        
        if sz_un(i) == 0
            if nnz(K(:,f)) == 0
               pis(idx,f) = ones(sumidx,1);
            end
            continue
        end
        
        %columns of Fm that contain i nonzero elements
        n_idx         = n_mat(:,idx.');
        n_idx_find    = find(n_idx);
        [n_idx_row,~] = ind2sub(size(n_idx),n_idx_find);
        %%
        % $\texttt{Fm\_idx\_pos}$ contains the entries of $\texttt{F\_multi}$ that correspond
        % to the multi-indices that have $i$ nonzero elements. It is therefore a  $\texttt{sumidx
        % *sz\_un(i)}$ by 1 array.
        n_idx_pos     = n_idx(n_idx_find);
        %%
        % This step checks where condition 2 is fulfilled. $\texttt{h\_abs\{f,i\}}$
        % contains a $\texttt{sz\_un(i)}$ by $\texttt{combnos(i)}$ dimensionaly array.
        % In every column it contains the absolute values of all multi_indices of one
        % combination $\{\mathbf{h}_v\}_v$ that fulfills condition 1 for $\texttt{f}$
        % and contains $\texttt{sz\_un(i)}$ elements. Condition 2 is checked simultaneously
        % for all $\mathbf{m}$ of order $\texttt{order}$ that contain $\texttt{sz\_un(i)}$
        % nonzero entries.
        %
        % $$\texttt{h\_abs\{f,i\}} = \pmatrix{ \mathbf{h_1^1} & \cdots & \mathbf{h_1^\texttt{combnos(i)}}\cr
        % \mathbf{h_2^1} & \cdots & \mathbf{h_2^\texttt{combnos(i)}}\cr \vdots & \cdots
        % & \vdots\cr \mathbf{h_{\texttt{sz\_un(i)}}^1} & \cdots & \mathbf{h_{\texttt{sz\_un(i)}}^\texttt{combnos(i)}}}
        % $$
        %
        % And therefore if the size $2n$ multi indices that have $\texttt{sz\_un(i)}$
        % nonzero elements are $\mathbf{m}_1, ... , \mathbf{m}_\texttt{sumidx}$, and we
        % define $\mathbf{m}_1^+$ as the size $\texttt{sz\_un(i)}$ multi-index containing
        % the nonzero elements of $\mathbf{m}_1$,then condition 2 is checked as follows:
        %
        % $$\texttt{Cond\_dum} = \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_1^+\cr\texttt{h\_abs\{f,i\}}
        % ==  \mathbf{m}_2^+ \cr \vdots \cr\texttt{h\_abs\{f,i\}}==
        % \mathbf{m}_\texttt{sumidx}^+} \in \mathbf{N} \textrm{mod 2}^{\texttt{sumidx}\ \times \ \texttt{combnos(i) }}$$
        %
        
        Cond_dum = repmat(h_abs{f,i},sumidx,1) >= full(n_idx_pos);
        
        %%
        % Now we would like to check which combinations fulfill condition 2 for all
        % of their elements. This corresponds to columns of $\texttt{h\_abs\{f,i\}} ==
        % \mathbf{m}_j^+$ where all elements are one. So summing over the rows only the
        % columns that have $\texttt{sz\_un(i)}$ as their entry correspond to valid combinations
        % that fulfill condition 2to for $\mathbf{m}_j^+$, and this has to be done for
        % $j = 1,...,\texttt{sumidx}$.
        %
        % To do this we transpose $\texttt{Cond\_dum}$ and permute the first two dimensions.
        % Furthermore, now a third dimension is added which each corresponds to one $\mathbf{m}_i^+$.
        % reshape, such that every slice of 3rd dim corresponds to
        % conditions for one m, first dimension
        %
        Cond_dum = reshape(Cond_dum.',[],sz_un(i),sumidx);
        
        % permute, every column now contains conds for one combo of
        % h_is, sum all those cond values, if they are all one in a
        % column, they contribute.
        Cond_dum =  sum(permute( Cond_dum,[2,1,3]),1);
        %%
        % Now a slice of the third dimension looks like $\texttt{Cond\_dum(:,:,j)} =
        % \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_j^+} $. The sum over the rows
        % reveals which combos contribute. The resulting vector is recast, such that every
        % column corresponds to one $\mathbf{m}_j^+$ and the rows correspond to the combinations
        % that fulfill condition 1. The ones that also fulfill condition 2 are logical
        % ones, the others are zero.

        % check if every vector of a combo fulfills cond, if not
        % discard it
        Cond     = sparse(reshape(Cond_dum == full(sz_un(i)),combnos(f,i),[] ));

        if nnz(Cond)==0
            continue
        end
        %%
        % The array indices reads out the index of the valid combinations. Specifically
        % if the different combinations are numbered with numbers 1 to $\texttt{combnos(f,i)}$,
        % then it assigns every valid combination the number it corresponds to.

        %contains indices to read out the ones fulfilling cond2
        %from h
        indices  = repmat([1:combnos(f,i)].',1,sumidx);
        Cond_ind = indices(Cond);
        %%
        % Consequently all valid combinations of multi-indices are explicitly read out
        % into a array that contains all of the multi-indices in its second dimension.
        % All valid combinations for $\mathbf{m}_1^+$ are in it as a sequence, followed
        % by all valid combinations for $\mathbf{m}_2^+$ and so forth.

        %All combos in first dim. each combo has nns(ind)
        %contributions - to get back, reshape to l, nns(ind), []
        h_i      = reshape( h{f,i}(:,:,reshape(Cond_ind,[],1)) ,l,[]);
        %%
        % In order to read out the composition coefficients corresponding to all those
        % multi-indices we have to know their position in a set of reverse lexicographical
        % ordering of all multi-indices of their respective order and size. In order to
        % do this efficient, unique multi-indices are extracted from $\texttt{h\_i}$,
        % and their position is calculated, in either conjugate ordering (real system)
        % or in reverse lex. ordering (non real system). Then the subindices of all multi-indices
        % are stored in the array $\texttt{h\_i\_multi}$.

        [h_i_un,~,h_i_ic] = unique(h_i.','rows');
        h_i_idx_temp    = <a href="../../../Library/Manifold/private/multi_index_2_ordering.html">multi_index_2_ordering</a>(h_i_un.','revlex',[]);
        h_i_idx         = h_i_idx_temp(h_i_ic.');
        %%
        % To read out the composition coefficients at the right order the absolute values
        % of the multi-indices also has to be known. They are stored in $\texttt{h\_i\_abs}$.
        if l > 1
            h_i_abs    = sum(h_i_un.');
        else
            h_i_abs = h_i_un.';
        end
        [h_i_abs_un,~,h_i_abs_ic] = unique(h_i_abs);
        %%
        % $\texttt{list\_1\_tmp}$ contains the positions of the nonzero elements of
        % all the multi-indices $\mathbf{m}_j^+$ in column $j$. Then each column is replicated
        % by the amount of combinations that fulfill both condition 1 and condition 2,
        % which is given by $\texttt{sum(Cond,1)}$, since $\texttt{Cond}$ contains in
        % column $j$ and row $r$ logical indices that indicate wheter combination $r$
        % fulfills both conditions for $\mathbf{m}_j^+$. That is then reshaped, such that
        % the entry $u$ in $\texttt{list\_1}$ contains the index $q$ of the composition
        % coefficient $H_{q,.,.}$ that the multi-index in position $u$ in $\texttt{h\_i}$
        % corresponds to.
        %contains the row index for all of the valid combos for
        %all ms in the same ordering as in HV
        list_1_tmp = reshape(n_idx_row,sz_un(i),[]);
        list_1     = reshape(repelem(list_1_tmp,1,sum(Cond,1)),1,[] );
        %%
        % The same thing is done for the entries (not the positions) of all the multi-indices
        % $\mathbf{m}_j^+$. The entry $u$ in $\texttt{list\_2}$ contains the value $m_q$
        % of the composition coefficient $H_{.,m_q,.}$ that the multi-index in position
        % $u$ in $\texttt{h\_i}$ corresponds to.
        %contains the entries of m for the valid combos for
        %all ms in the same ordering as in HV
        list_2_tmp = reshape(n_idx_pos,sz_un(i),[]);
        list_2     = reshape(repelem(list_2_tmp,1,sum(Cond,1)),1,[]);
        %%
        % What is left now is to multiply and add the indices accordingly to get the
        % right force contribution. Firstly all the composition coefficients are ready
        % out into $\texttt{pi\_dum}$.
        pi_dum  = ones(size(h_i,2),1);
        run_ord = 1;

        for ord = h_i_abs_un
            %%
            % The logical index $\texttt{idx\_dum}$ contains the positions of all multi-indices
            % in $\texttt{h\_i}$ that have order $\texttt{ord}$. The explicit positions of
            % them are stored in $\texttt{I\_ord\_pos}$.
            idx_dum = 1:size(h_i_abs_ic.',2);
            idx_dum = idx_dum(h_i_abs_ic.' == run_ord);
            idx_dum = (h_i_ic == idx_dum);
            idx_dum = sum(idx_dum,2);
            I_ord =  logical(idx_dum);

            %%
            % The values corresponding to those multi_indices of order $\texttt{ord}$ are
            % read out of the arrays that specify the position of the composition coefficients
            % for each of the multi-indices, being the phase space direction they correspond
            % to, the multi-index subindex in the reverse lexicographically ordered set they
            % have and the multi-index entry of the multi-index $\mathbf{m}_j^+$ they correspond
            % to.
            I_1   = list_1(I_ord);
            I_2   = h_i_idx(I_ord);
            I_3   = list_2(I_ord);
            
            %%
            % In order to make use of the symmetry of the SSM-coefficients, all the multi-indices
            % that in conjugate ordering have subindex bigger than the conjugate center index
            % are changed to their conjugate counterpart, and for them then conjugate composition
            % coefficients corresponding to this conjugate multi-index are read out.
            z_ord = nchoosek(ord+l-1,l-1);
            
            %split in the two index parts about conjugate
            %center index at order ord

            lin_idx  = sub2ind([N,z_ord,ord],I_1,I_2,I_3);
            pi_dum(I_ord) =  field.H{ord}(lin_idx);

            
            run_ord = run_ord +1;
        end
        
        %%
        % The following step multiplies all composition coefficients that correspond
        % to one combination of multi-indices fulfilling condition 1 and 2.
        %multiplication
        pi_dum = prod(reshape(pi_dum, sz_un(i),[]),1);
        %%
        % Next all the values of $\texttt{pi\_dum}$ corresponding to the same multi-index
        % $\mathbf{m}_j^+$ have to be added. This is done by creating an array $\texttt{list\_3}$
        % that contains for each entry in $\texttt{pi\_dum}$ the index $j$ of the size
        % $2n$ multi-index it corresponds to. Using $\texttt{accumarray}$ the values that
        % correspond to the same index $j$ are added up and then stored in the array $\texttt{pi}$
        % that contains all the composition terms.
        %sum over combos and put into position
        
        list_3 = repelem([1:sumidx].',sum(Cond,1));

        % Indices to read out the contributions into correct position
        n_contrib = sum(Cond,1)>0;
        idx_pos   = find(idx); 
        
        accum_pi  = accumarray(reshape(list_3,[],1),pi_dum);        
        pis(idx_pos(n_contrib),f) = accum_pi(find(n_contrib));
    end
end
end

function [pis] = pink_conj(F_multi,K,field)

% Conjugate center index at all orders, for
% imaginary system this is empty since then no symmetry is
% inherent and we only need the number of multi-indices that
% exist at order k, given by nchoosek(k+l-1,l-1)
k           = sum(K(:,1),1);    % Order of computation
Z_cci       = field.Z_cci;
z_k         = Z_cci(k);
l           = size(K,1);        % SSM dimension
% Phase space dimension
N           = field.N;

% if system is not real, then full set of order k multi-indices in reverse lex. ordering
revlex2conj = field.revlex2conj;   % Set to convert indices from rev. lex. to conjugate ordering

% nonzero entries in the multi-index array
F_multi_pos   = (F_multi ~= 0);
sz          = size(F_multi,2);
col_pos     = 1:sz;
%%
% Initialise space for the $\pi_{\mathbf{m},\mathbf{k}_f}$.
pis = zeros(size(col_pos,2),z_k);

%%
% The array $\texttt{sz\_pos}$ is a row vector containing in each row the number
% of nonzero entries of the multi-index the row corresponds to. This is useful,
% since $H_{i,0,\mathbf{h}} = 0$ for any nonzero $\mathbf{h}$. Therefore for each
% $\mathbf{m}$ in $\texttt{F\_multi}$ we only have to find the composition coefficients
% corresponding to the nonzero entries of $\mathbf{m}$. Furthermore then condition
% 1 looks like $\sum_{v,m_v \neq 0} \mathbf{h}_v = \mathbf{k}_f$. For each $f$
% and $\mathbf{m}$ all such combinations have to be found.
sz_pos   = sum(F_multi_pos,1);

%%
% This function computes all those combinations for all order $m$ multi-indices
% $\mathbf{m}$ and all $f$. It does so by considering unique numbers in $\texttt{sz\_pos}$
% and using them as the number of multi-indices $\mathbf{h}_i$ that have to sum
% up to $\mathbf{k}_f$ for all $f$.
%
% $\texttt{h}$ is a cell array, that contains in its first dimension the combinations
% for all $f$ and its second dimension corresponds to unique numbers in $\texttt{sz\_pos}$.
% They are stored in $\texttt{sz\_un}$. For each entry in $\texttt{sz\_pos}$ the
% corresponding entry in $\texttt{sz\_un\_ic}$ gives the column that it corresponds
% to in $\texttt{h}$.
%
% $\texttt{h\{f,i\}}$ contains a 3 dimensional array. The first dimension has
% size $l$, the second hase size $\texttt{sz\_un(i)}$. Its third dimension has
% size $\texttt{combnos(i)}$.
%
% This array contains in every matrix a set $\{\mathbf{h}_{v}\}_{v}$ that fulfills
% condition 1 for $\mathbf{k}_f$ that is stored in $\texttt{K2(:,f)}$. Each set
% consists of $\texttt{sz\_un(i)}$ elements.
%
% $\texttt{combnos}$ contains the amount of combinations that exist for every
% tuple $(\texttt{f,i})$.
[h, combnos,sz_un,sz_un_ic] = multi_<a href="../../../Library/Features/misc/nsumk.html">nsumk</a>(sz_pos,K);

%stores the order of all the multi-indices in h
h_abs = cellfun(@(x) reshape(sum(x,1),size(x,2),[]), h, 'UniformOutput',false);

%loop over all the order k multi-indices with index below center
%index in conjugate ordering
for f = 1:z_k
    
    %loop over unique amounts of nonzero entries in the
    %multi-indices m
    for i = 1:size(sz_un,2)
        
        %position of multi-indices in F_multi that have sz_un(i) nonzero entries
        idx    = sz_un_ic == i;
        
        %number of multi-indices in F_multi that have i nonzero entries
        sumidx = sum(idx);
        
        %columns of Fm that contain i nonzero elements
        Fm_idx         = F_multi(:,idx.');
        Fm_idx_find    = find(Fm_idx);
        [Fm_idx_row,~] = ind2sub(size(Fm_idx),Fm_idx_find);
        %%
        % $\texttt{Fm\_idx\_pos}$ contains the entries of $\texttt{F\_multi}$ that correspond
        % to the multi-indices that have $i$ nonzero elements. It is therefore a  $\texttt{sumidx
        % *sz\_un(i)}$ by 1 array.
        Fm_idx_pos     = Fm_idx(Fm_idx_find);
        %%
        % This step checks where condition 2 is fulfilled. $\texttt{h\_abs\{f,i\}}$
        % contains a $\texttt{sz\_un(i)}$ by $\texttt{combnos(i)}$ dimensionaly array.
        % In every column it contains the absolute values of all multi_indices of one
        % combination $\{\mathbf{h}_v\}_v$ that fulfills condition 1 for $\texttt{f}$
        % and contains $\texttt{sz\_un(i)}$ elements. Condition 2 is checked simultaneously
        % for all $\mathbf{m}$ of order $\texttt{order}$ that contain $\texttt{sz\_un(i)}$
        % nonzero entries.
        %
        % $$\texttt{h\_abs\{f,i\}} = \pmatrix{ \mathbf{h_1^1} & \cdots & \mathbf{h_1^\texttt{combnos(i)}}\cr
        % \mathbf{h_2^1} & \cdots & \mathbf{h_2^\texttt{combnos(i)}}\cr \vdots & \cdots
        % & \vdots\cr \mathbf{h_{\texttt{sz\_un(i)}}^1} & \cdots & \mathbf{h_{\texttt{sz\_un(i)}}^\texttt{combnos(i)}}}
        % $$
        %
        % And therefore if the size $2n$ multi indices that have $\texttt{sz\_un(i)}$
        % nonzero elements are $\mathbf{m}_1, ... , \mathbf{m}_\texttt{sumidx}$, and we
        % define $\mathbf{m}_1^+$ as the size $\texttt{sz\_un(i)}$ multi-index containing
        % the nonzero elements of $\mathbf{m}_1$,then condition 2 is checked as follows:
        %
        % $$\texttt{Cond\_dum} = \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_1^+\cr\texttt{h\_abs\{f,i\}}
        % ==  \mathbf{m}_2^+ \cr \vdots \cr\texttt{h\_abs\{f,i\}}==
        % \mathbf{m}_\texttt{sumidx}^+} \in \mathbf{N} \textrm{mod 2}^{\texttt{sumidx} \times \texttt{combnos(i)}}$$
        
        Cond_dum = repmat(h_abs{f,i},sumidx,1) >= full(Fm_idx_pos);
        %%
        % Now we would like to check which combinations fulfill condition 2 for all
        % of their elements. This corresponds to columns of $\texttt{h\_abs\{f,i\}} ==
        % \mathbf{m}_j^+$ where all elements are one. So summing over the rows only the
        % columns that have $\texttt{sz\_un(i)}$ as their entry correspond to valid combinations
        % that fulfill condition 2 to for $\mathbf{m}_j^+$, and this has to be done for
        % $j = 1,...,\texttt{sumidx}$.
        %
        % To do this we transpose $\texttt{Cond\_dum}$ and permute the first two dimensions.
        % Furthermore, now a third dimension is added which each corresponds to one $\mathbf{m}_i^+$.
        %reshape, such that every slice of 3rd dim corresponds to
        %conditions for one m, first dimension
        Cond_dum = reshape(Cond_dum.',[],sz_un(i),sumidx);
        %permute, every column now contains conds for one combo of
        %h_is, sum all those cond values, if they are all one in a
        %column, they contribute.
        Cond_dum =  sum(permute( Cond_dum,[2,1,3]),1);
        %%
        % Now a slice of the third dimension looks like $\texttt{Cond\_dum(:,:,j)} =
        % \pmatrix{\texttt{h\_abs\{f,i\}} ==  \mathbf{m}_j^+} $. The sum over the rows
        % reveals which combos contribute. The resulting vector is recast, such that every
        % column corresponds to one $\mathbf{m}_j^+$ and the rows correspond to the combinations
        % that fulfill condition 1. The ones that also fulfill condition 2 are logical
        % ones, the others are zero.
        %check if every vector of a combo fulfills cond, if not
        %discard it
        Cond     = reshape(Cond_dum == full(sz_un(i)),combnos(f,i),[] );
        if nnz(Cond) == 0
            continue
        end
        %%
        % The array indices reads out the index of the valid combinations. Specifically
        % if the different combinations are numbered with numbers 1 to $\texttt{combnos(f,i)}$,
        % then it assigns every valid combination the number it corresponds to.
        %contains indices to read out the ones fulfilling cond2
        %from h
        indices  = repmat([1:combnos(f,i)].',1,sumidx);
        Cond_ind = indices(Cond);
        %%
        % Consequently all valid combinations of multi-indices are explicitly read out
        % into a array that contains all of the multi-indices in its second dimension.
        % All valid combinations for $\mathbf{m}_1^+$ are in it as a sequence, followed
        % by all valid combinations for $\mathbf{m}_2^+$ and so forth.
        %All combos in first dim. each combo has nns(ind)
        %contributions - to get back, reshape to l, nns(ind), []
        h_i      = reshape( h{f,i}(:,:,reshape(Cond_ind,[],1)) ,l,[]);
        %%
        % In order to read out the composition coefficients corresponding to all those
        % multi-indices we have to know their position in a set of reverse lexicographical
        % ordering of all multi-indices of their respective order and size. In order to
        % do this efficient, unique multi-indices are extracted from $\texttt{h\_i}$,
        % and their position is calculated, in either conjugate ordering (real system)
        % or in reverse lex. ordering (non real system). Then the subindices of all multi-indices
        % are stored in the array $\texttt{h\_i\_multi}$.
        [h_i_un,~,h_i_ic] = unique(h_i.','rows');
        h_i_idx_temp    = <a href="../../../Library/Manifold/private/multi_index_2_ordering.html">multi_index_2_ordering</a>(h_i_un.',field.ordering,revlex2conj);
        h_i_idx         = h_i_idx_temp(h_i_ic.');
        %%
        % To read out the composition coefficients at the right order the absolute values
        % of the multi-indices also has to be known. They are stored in $\texttt{h\_i\_abs}$.
        h_i_abs    = sum(h_i_un.');
        [h_i_abs_un,~,h_i_abs_ic] = unique(h_i_abs);
        %%
        % $\texttt{list\_1\_tmp}$ contains the positions of the nonzero elements of
        % all the multi-indices $\mathbf{m}_j^+$ in column $j$. Then each column is replicated
        % by the amount of combinations that fulfill both condition 1 and condition 2,
        % which is given by $\texttt{sum(Cond,1)}$, since $\texttt{Cond}$ contains in
        % column $j$ and row $r$ logical indices that indicate wheter combination $r$
        % fulfills both conditions for $\mathbf{m}_j^+$. That is then reshaped, such that
        % the entry $u$ in $\texttt{list\_1}$ contains the index $q$ of the composition
        % coefficient $H_{q,.,.}$ that the multi-index in position $u$ in $\texttt{h\_i}$
        % corresponds to.
        %contains the row index for all of the valid combos for
        %all ms in the same ordering as in HV
        list_1_tmp = reshape(Fm_idx_row,sz_un(i),[]);
        list_1     = reshape(repelem(list_1_tmp,1,sum(Cond,1)),1,[] );
        %%
        % The same thing is done for the entries (not the positions) of all the multi-indices
        % $\mathbf{m}_j^+$. The entry $u$ in $\texttt{list\_2}$ contains the value $m_q$
        % of the composition coefficient $H_{.,m_q,.}$ that the multi-index in position
        % $u$ in $\texttt{h\_i}$ corresponds to.
        %contains the entries of m for the valid combos for
        %all ms in the same ordering as in HV
        list_2_tmp = reshape(Fm_idx_pos,sz_un(i),[]);
        list_2     = reshape(repelem(list_2_tmp,1,sum(Cond,1)),1,[]);
        %%
        % What is left now is to multiply and add the indices accordingly to get the
        % right force contribution. Firstly all the composition coefficients are ready
        % out into $\texttt{pi\_dum}$.
        pi_dum  = ones(size(h_i,2),1);
        run_ord = 1;
        for ord = h_i_abs_un
            %%
            % The logical index $\texttt{idx\_dum}$ contains the positions of all multi-indices
            % in $\texttt{h\_i}$ that have order $\texttt{ord}$. The explicit positions of
            % them are stored in $\texttt{I\_ord\_pos}$.
            idx_dum = 1:size(h_i_abs_ic.',2);
            idx_dum = idx_dum(h_i_abs_ic.' == run_ord);
            idx_dum = (h_i_ic == idx_dum);
            idx_dum = sum(idx_dum,2);
            I_ord =  logical(idx_dum);
            I_ord_pos = find(I_ord);
            %%
            % The values corresponding to those multi_indices of order $\texttt{ord}$ are
            % read out of the arrays that specify the position of the composition coefficients
            % for each of the multi-indices, being the phase space direction they correspond
            % to, the multi-index subindex in the reverse lexicographically ordered set they
            % have and the multi-index entry of the multi-index $\mathbf{m}_j^+$ they correspond
            % to.
            I_1   = list_1(I_ord);
            I_2   = h_i_idx(I_ord);
            I_3   = list_2(I_ord);
            
            %%
            % In order to make use of the symmetry of the SSM-coefficients, all the multi-indices
            % that in conjugate ordering have subindex bigger than the conjugate center index
            % are changed to their conjugate counterpart, and for them then conjugate composition
            % coefficients corresponding to this conjugate multi-index are read out.
            z_ord = nchoosek(ord+l-1,l-1);
            z_cci_ord = Z_cci(ord);
            
            %split in the two index parts about conjugate
            %center index at order ord
            idx_2   = I_2 <= z_cci_ord;
            
            lin_idx_a  = sub2ind([N,Z_cci(ord),ord],I_1(idx_2),I_2(idx_2),I_3(idx_2));
            %[N,Z_cci(ord),ord],I_1(idx_2),I_2(idx_2),I_3(idx_2)
            %field.H{ord},(lin_idx_a)
            
            pi_dum(I_ord_pos(idx_2)) =  field.H{ord}(lin_idx_a);
            
            lin_idx_b  = sub2ind([N,Z_cci(ord),ord],I_1(~idx_2),z_ord-I_2(~idx_2)+1,I_3(~idx_2));
            pi_dum(I_ord_pos(~idx_2)) = conj(field.H{ord}(lin_idx_b));
            
            
            run_ord = run_ord +1;
        end
        %%
        % The following step multiplies all composition coefficients that correspond
        % to one combination of multi-indices fulfilling condition 1 and 2.
        %multiplication
        pi_dum = prod(reshape(pi_dum, sz_un(i),[]),1);
        %%
        % Next all the values of $\texttt{pi\_dum}$ corresponding to the same multi-index
        % $\mathbf{m}_j^+$ have to be added. This is done by creating an array $\texttt{list\_3}$
        % that contains for each entry in $\texttt{pi\_dum}$ the index $j$ of the size
        % $2n$ multi-index it corresponds to. Using $\texttt{accumarray}$ the values that
        % correspond to the same index $j$ are added up and then stored in the array $\texttt{pi}$
        % that contains all the composition terms.
        %sum over combos and put into position
        
        list_3 = repelem([1:sumidx].',sum(Cond,1));

        % Indices to read out the contributions into correct position
        n_contrib = sum(Cond,1)>0;
        idx_pos   = find(idx); 
        
        accum_pi  = accumarray(reshape(list_3,[],1),pi_dum);        
        pis(idx_pos(n_contrib),f) = accum_pi(find(n_contrib));

    end
end
end

            ##### SOURCE END #####
        --></body></html></body></html>