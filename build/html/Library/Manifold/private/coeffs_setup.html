
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><body><div class="banner"><a href="../../../index.html"><img alt="Logo" class="logo" src="../../../logo.png" style="float:right" width="200"/></a></div><html><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--

                    This HTML was auto-generated from MATLAB code.
                    To make changes, update the MATLAB code and republish this document.
                --><title>COEFFS_SETUP</title><meta content="MATLAB 9.14" name="generator"/><link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/><meta content="2023-09-09" name="DC.date"/><meta content="coeffs_setup.m" name="DC.source"/><style type="text/css">
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

            html { min-height:100%; margin-bottom:1px; }
            html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
            html body td { vertical-align:top; text-align:left; }

            h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
            h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
            h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

            a { color:#005fce; text-decoration:none; }
            a:hover { color:#005fce; text-decoration:underline; }
            a:visited { color:#004aa0; text-decoration:none; }

            p { padding:0px; margin:0px 0px 20px; }
            img { padding:0px; margin:0px 0px 20px; border:none; }
            p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

            ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
            ul li { padding:0px; margin:0px 0px 7px 0px; }
            ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
            ul li ol li { list-style:decimal; }
            ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
            ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
            ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
            ol li ol li { list-style-type:lower-alpha; }
            ol li ul { padding-top:7px; }
            ol li ul li { list-style:square; }

            .content { font-size:1.2em; line-height:140%; padding: 20px; }

            pre, code { font-size:12px; }
            tt { font-size: 1.2em; }
            pre { margin:0px 0px 20px; }
            pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
            pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
            pre.error { color:red; }

            @media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

            span.keyword { color:#0000FF }
            span.comment { color:#228B22 }
            span.string { color:#A020F0 }
            span.untermstring { color:#B20000 }
            span.syscmd { color:#B28C00 }
            span.typesection { color:#A0522D }

            .footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
            .footer p { margin:0px; }
            .footer a { color:#878787; }
            .footer a:hover { color:#878787; text-decoration:underline; }
            .footer a:visited { color:#878787; }

            table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
            table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

            .center {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 50%;
              }



        </style></head><body><div class="content"><h1>COEFFS_SETUP</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">SSM_MULTI Setup for the mutli-index calculation</a></li><li><a href="#4">No symmetries can be exploited, set up in rev_lex ordering</a></li><li><a href="#6">Setup for System with Symmetries, set up in conj. ordering</a></li><li><a href="#7">Conversion of indices and conjugate center index</a></li><li><a href="#8">Perparing first order coefficients</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span>[W_0_1,R_0_1, multi_input] = coeffs_setup(obj,order,DStype)
        </pre><h2 id="2">SSM_MULTI Setup for the mutli-index calculation</h2><p>This function checks if the symmetries an be used for SSM computation. This is the  case if the inputs <span class="MathJax_Preview"><img alt="$\texttt{A,B,F}$" src="coeffs_setup_eq06829104332365095379-Rescaled.png" style="width: 34.8px; height: auto;"/></span><script type="math/tex">\texttt{A,B,F}</script> are all purely real and the eigenvectors are compl. conjugate for complex conjugate eigenvalues , we say the system is real. If this is not the case, then the full coefficients get calculated and we say the system is not (purely) real. This function is designed to distinguish between the case where inherent symmetries are present and the case where there are no such symmetries and then prepare to calculate the SSM coefficients.</p><p>If the system is real (the symmetries exist) then only the coefficients up to the conjugate center index (in conjugate ordering) are calculated.</p><pre class="codeinput">Lambda_M = sparse(diag(obj.E.spectrum)); <span class="comment">% Master Eigenvalues, in order of rev_lex ordering</span>
Lambda_M_vector      = diag(Lambda_M);

V_M = obj.E.basis;          <span class="comment">% Left eigenvectors of the modal subspace, order corresponds to rev_lex</span>
W_M = obj.E.adjointBasis;   <span class="comment">% Right eigenvectors of the modal subspace</span>
<span class="keyword">switch</span> DStype
    <span class="keyword">case</span> <span class="string">'complex'</span>
        </pre><h2 id="4">No symmetries can be exploited, set up in rev_lex ordering</h2><pre class="codeinput">        W_0_1(1).coeffs = V_M;
        R_0_1(1).coeffs = Lambda_M;
        H{1}  = W_0_1(1).coeffs;

        <span class="comment">% Set up array containing index numbers at every order</span>
        l   = size(Lambda_M,1);
        z_k = zeros(1,order);
        <span class="keyword">for</span> k = 1:order
            z_k(k) = nchoosek(k+l-1,l-1); <span class="comment">% At order k, SSM dim l there are z_k(k,l) spatial multi-indices</span>
        <span class="keyword">end</span>

        multi_input.Z_cci = z_k; <span class="comment">%in this case there is no conjugate center index, the full index set is treated</span>
        </pre><pre class="codeinput">     <span class="keyword">case</span> <span class="string">'real'</span>
        </pre><h2 id="6">Setup for System with Symmetries, set up in conj. ordering</h2><p>To make bookkeeping as easy as possible, the eigenvalues and the corresponding quantities are sorted such that the <span class="MathJax_Preview"><img alt="$l_i$" src="coeffs_setup_eq02983375260617841162-Rescaled.png" style="width: 6.0px; height: auto;"/></span><script type="math/tex">l_i</script> complex pairs are in the first <span class="MathJax_Preview"><img alt="$2l_i$" src="coeffs_setup_eq00051020446794087706-Rescaled.png" style="width: 13.2px; height: auto;"/></span><script type="math/tex">2l_i</script> positions of the linear reduced dynamics, the <span class="MathJax_Preview"><img alt="$l_r$" src="coeffs_setup_eq05447928976032674508-Rescaled.png" style="width: 8.4px; height: auto;"/></span><script type="math/tex">l_r</script> real eigenvalues are in the last <span class="MathJax_Preview"><img alt="$l_r$" src="coeffs_setup_eq05447928976032674508-Rescaled.png" style="width: 8.4px; height: auto;"/></span><script type="math/tex">l_r</script> positions. This is reverted at the end of computation. Sort input according to eigenvalues. Conjugate Evals in the first 2l_i positons, always have to be input in pairs! real ones in l_r last pos.</p><pre class="codeinput">        im_idx= find(imag(Lambda_M_vector) ~= 0); <span class="comment">% pos. of imaginary ev pairs in master modal subspace</span>
        l_i   = length(im_idx)/2;                 <span class="comment">% number of imaginary ev pairs in master modal subspace</span>

        r_idx = find(imag(Lambda_M_vector) == 0); <span class="comment">% pos. of real eigenvalues in master modal subspace</span>
        l_r   = sum(imag(Lambda_M_vector) == 0);  <span class="comment">% number of real eigenvalues in master modal subspace</span>

        <span class="comment">% recast input such that first 2li directions correspond to imag. ev. pairs,</span>
        <span class="comment">% the last l_r correspond to real eigenvalues.</span>
        new_idx    = [im_idx,r_idx];
        V_M        = V_M     (:,new_idx);
        W_M        = W_M     (:,new_idx);
        Lambda_M   = Lambda_M(:,new_idx);
        Lambda_M_vector = Lambda_M_vector(new_idx);
        </pre><h2 id="7">Conversion of indices and conjugate center index</h2><p>To convert between conjugate and reverse lexicographical ordering we construct all index sets that do so. If the function computing them is efficient enough storing them will no longer be necessary. For now we keep them in the <span class="MathJax_Preview"><img alt="$\texttt{data}$" src="coeffs_setup_eq08003352684765911397-Rescaled.png" style="width: 28.799999999999997px; height: auto;"/></span><script type="math/tex">\texttt{data}</script> field to access them directly.</p><pre class="codeinput">        <span class="comment">% conjugate indices</span>
        <span class="comment">%Z_cci    -  conjugate center indices</span>
        <span class="comment">%conj2lex -  Set to convert indices from conjugate to rev. lex. ordering</span>
        <span class="comment">%lex2conj -  Set to convert indices from rev. lex. to conjugate ordering</span>
        [multi_input] = conjugate_ordering(order,l_r,l_i);
        </pre><h2 id="8">Perparing first order coefficients</h2><p>We convert the first order reduced dynamics and SSM-coefficients to conjugate ordering to exploit the symmetry in the calculation. Sort input in conjugate ordering</p><pre class="codeinput">        idx           = multi_input.revlex2conj{1};
        V_M_conj      = V_M(:,idx );    <span class="comment">%in conj. ordering</span>
        Lambda_M_conj = Lambda_M(:,idx);  <span class="comment">%in conj. ordering</span>


        V_M_conj(:,1:multi_input.Z_cci(1)); <span class="comment">% should be removed</span>
        W_0_1(1).coeffs = V_M_conj(:,1:multi_input.Z_cci(1));
        R_0_1(1).coeffs = Lambda_M_conj(:,1:multi_input.Z_cci(1));
        H{1}  = W_0_1(1).coeffs;
        </pre><pre class="codeinput"><span class="keyword">end</span>

multi_input.H = H;
multi_input.W_M = W_M;
multi_input.Lambda_M_vector = Lambda_M_vector;
multi_input.nl_order = numel(obj.System.F);
multi_input.l = size(Lambda_M,2);
        </pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> [conjugate] = conjugate_ordering(max_order,l_r,l_i)
        </pre><p>Creates conjugate ordered set indices of multi-indices up to order max_order. Conjugate ordering is defined in <span class="MathJax_Preview"><img alt="$\textit{Explicit Kernel Extraction and Proof ofSymmetries of SSM Coefficients - Multi-Indexversion}$" src="coeffs_setup_eq05540851300891867700-Rescaled.png" style="width: 536.4px; height: auto;"/></span><script type="math/tex">\textit{Explicit Kernel Extraction and Proof ofSymmetries of SSM Coefficients - Multi-Indexversion}</script></p><p><b>Input:</b></p><div><ul><li>max_order   highest order of multi-indices that the conjugate ordering is              wanted for</li></ul></div><div><ul><li>l_r number of real eigenvalues in the master subspace</li></ul></div><div><ul><li>l_i number of imaignary pairs of eigenvalues in the master subspace</li></ul></div><p><b>Output</b> for a conjugately ordered set Z, rev. lex ordered set K:</p><div><ul><li>lex2conj index array for construction.   - K(:,lex2conj) =Z</li></ul></div><div><ul><li>conj2lex index array for reconstruction. - Z(:,conj2lex) = K     i.e if Z_idx(f) = i, then k_f in K(:,f) is in position i in Z</li></ul></div><div><ul><li>cci_k - conjugate center index of the set</li></ul></div><pre class="codeinput">Z_cci    = zeros(1,max_order); <span class="comment">% conjugate center index array</span>
revlex2conj = cell(1,max_order);  <span class="comment">% index sets converting lex set to conj set</span>
conj2revlex = cell(1,max_order);  <span class="comment">% index sets converting conj set to lex set</span>

<span class="keyword">for</span> k = 1:max_order
    I = conjugate_flip(l_i,l_r);
    <span class="comment">% Multi_indices in reverse lexicographical ordering</span>
    K = flip(sortrows(<a href="../../../Library/Features/misc/nsumk.html">nsumk</a>(l_r+2*l_i,k,<span class="string">'nonnegative'</span>)).',2);
    Y = K(I,:);
    Exempt      = all(K-Y==0);
    Y(:,Exempt) = [];

    <span class="comment">%Put m,m_c next to each other</span>
    Z          = [K(:,~Exempt);Y];
    Z          = reshape(Z, size(K,1),[]);

    <span class="comment">%index out all the combos of m, bar(m) that appear twice</span>
    [~,Z_ia,~] = unique(Z.',<span class="string">'rows'</span>);
    [~,Z_Ia]   = sort(Z_ia);
    Z     = Z(:,Z_ia(Z_Ia));

    <span class="comment">% sort the remaining multi-indices</span>
    idx_1 = 1:2:size(Y,2);
    idx_2 = size(Y,2)-idx_1+1;
    Z     = [Z(:,idx_1),K(:,Exempt),Z(:,idx_2)];

    <span class="comment">% conjugate center index</span>
    cci_k = sum(Exempt,2) + length(idx_1);

    <span class="comment">% index arrays</span>
    [~,~,conj2lex_k] = intersect(K.',Z.',<span class="string">'rows'</span>,<span class="string">'stable'</span>);
    [~,~,lex2conj_k] = intersect(Z.',K.',<span class="string">'rows'</span>,<span class="string">'stable'</span>);

    conj2revlex{k} = conj2lex_k.';
    revlex2conj{k} = lex2conj_k.';
    Z_cci(k)    = cci_k;
<span class="keyword">end</span>

conjugate.conj2revlex = conj2revlex;
conjugate.revlex2conj = revlex2conj;
conjugate.Z_cci    = Z_cci;
conjugate.l_i      = l_i;
conjugate.l_r      = l_r;
        </pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> [idx] = conjugate_flip(l_i,l_r)
        </pre><p>This function computes and index array that flips the conjugate coordinate directions Conjugate coordinate directions are defined in <span class="MathJax_Preview"><img alt="$\textit{Explicit Kernel Extraction and Proof ofSymmetries of SSM Coefficients - Multi-Indexversion}$" src="coeffs_setup_eq05540851300891867700-Rescaled.png" style="width: 536.4px; height: auto;"/></span><script type="math/tex">\textit{Explicit Kernel Extraction and Proof ofSymmetries of SSM Coefficients - Multi-Indexversion}</script></p><pre class="codeinput">idx = reshape(1:2*l_i,2,[]);
idx = reshape(flip(idx),1,[]);
idx = [idx,2*l_i+1:(2*l_i+l_r)];
        </pre><pre class="codeinput"><span class="keyword">end</span>
        </pre><p class="footer"><br/><a href="https://www.mathworks.com/products/matlab/">Published with MATLABÂ® R2023a</a><br/></p></div><!--
            ##### SOURCE BEGIN #####
            %% COEFFS_SETUP
%
%%
function[W_0_1,R_0_1, multi_input] = coeffs_setup(obj,order,DStype)
%% SSM_MULTI Setup for the mutli-index calculation
% This function checks if the symmetries an be used for SSM computation. This is the  case if the inputs $\texttt{A,B,F}$ are all purely
% real and the eigenvectors are compl. conjugate for complex conjugate eigenvalues
% , we say the system is real. If this is not the case, then the full coefficients
% get calculated and we say the system is not (purely) real. This function is designed to distinguish
% between the case where inherent symmetries are present and the case where there
% are no such symmetries and then prepare to calculate the SSM coefficients.
%
% If the system is real (the symmetries exist) then only the coefficients up
% to the conjugate center index (in conjugate ordering) are calculated.


%%
Lambda_M = sparse(diag(obj.E.spectrum)); % Master Eigenvalues, in order of rev_lex ordering
Lambda_M_vector      = diag(Lambda_M);

V_M = obj.E.basis;          % Left eigenvectors of the modal subspace, order corresponds to rev_lex
W_M = obj.E.adjointBasis;   % Right eigenvectors of the modal subspace
switch DStype
    case 'complex'
        %% No symmetries can be exploited, set up in rev_lex ordering
        
        W_0_1(1).coeffs = V_M;
        R_0_1(1).coeffs = Lambda_M;
        H{1}  = W_0_1(1).coeffs;
        
        % Set up array containing index numbers at every order
        l   = size(Lambda_M,1);
        z_k = zeros(1,order); 
        for k = 1:order
            z_k(k) = nchoosek(k+l-1,l-1); % At order k, SSM dim l there are z_k(k,l) spatial multi-indices
        end
        
        multi_input.Z_cci = z_k; %in this case there is no conjugate center index, the full index set is treated
     case 'real'
        %% Setup for System with Symmetries, set up in conj. ordering  
        % To make bookkeeping as easy as possible, the eigenvalues and the corresponding
        % quantities are sorted such that the $l_i$ complex pairs are in the first $2l_i$
        % positions of the linear reduced dynamics, the $l_r$ real eigenvalues are in
        % the last $l_r$ positions. This is reverted at the end of computation.
        % Sort input according to eigenvalues. Conjugate Evals in the first 2l_i positons, always have to be input in pairs!
        % real ones in l_r last pos.
        im_idx= find(imag(Lambda_M_vector) ~= 0); % pos. of imaginary ev pairs in master modal subspace
        l_i   = length(im_idx)/2;                 % number of imaginary ev pairs in master modal subspace
        
        r_idx = find(imag(Lambda_M_vector) == 0); % pos. of real eigenvalues in master modal subspace
        l_r   = sum(imag(Lambda_M_vector) == 0);  % number of real eigenvalues in master modal subspace
        
        % recast input such that first 2li directions correspond to imag. ev. pairs,
        % the last l_r correspond to real eigenvalues.
        new_idx    = [im_idx,r_idx];
        V_M        = V_M     (:,new_idx);
        W_M        = W_M     (:,new_idx);
        Lambda_M   = Lambda_M(:,new_idx);
        Lambda_M_vector = Lambda_M_vector(new_idx);
        %% Conversion of indices and conjugate center index
        % To convert between conjugate and reverse lexicographical ordering we construct
        % all index sets that do so. If the function computing them is efficient enough
        % storing them will no longer be necessary. For now we keep them in the $\texttt{data}$
        % field to access them directly.
        
        % conjugate indices
        %Z_cci    -  conjugate center indices
        %conj2lex -  Set to convert indices from conjugate to rev. lex. ordering
        %lex2conj -  Set to convert indices from rev. lex. to conjugate ordering
        [multi_input] = conjugate_ordering(order,l_r,l_i);
        
        %% Perparing first order coefficients
        % We convert the first order reduced dynamics and SSM-coefficients to conjugate
        % ordering to exploit the symmetry in the calculation.
        % Sort input in conjugate ordering
        idx           = multi_input.revlex2conj{1};
        V_M_conj      = V_M(:,idx );    %in conj. ordering
        Lambda_M_conj = Lambda_M(:,idx);  %in conj. ordering
        
        
        V_M_conj(:,1:multi_input.Z_cci(1)); % should be removed
        W_0_1(1).coeffs = V_M_conj(:,1:multi_input.Z_cci(1));
        R_0_1(1).coeffs = Lambda_M_conj(:,1:multi_input.Z_cci(1));
        H{1}  = W_0_1(1).coeffs;
end

multi_input.H = H;
multi_input.W_M = W_M;
multi_input.Lambda_M_vector = Lambda_M_vector;
multi_input.nl_order = numel(obj.System.F);
multi_input.l = size(Lambda_M,2);

end

function [conjugate] = conjugate_ordering(max_order,l_r,l_i)
%%
% Creates conjugate ordered set indices of multi-indices up to order
% max_order. Conjugate ordering is defined in $\textit{Explicit Kernel
% Extraction and Proof ofSymmetries of SSM Coefficients - Multi-Indexversion}$
%
% *Input:*
%
% * max_order   highest order of multi-indices that the conjugate ordering is 
%              wanted for
% 
% * l_r number of real eigenvalues in the master subspace
% 
% * l_i number of imaignary pairs of eigenvalues in the master subspace
%
% *Output*
% for a conjugately ordered set Z, rev. lex ordered set K:
% 
% * lex2conj index array for construction.   - K(:,lex2conj) =Z
% 
% * conj2lex index array for reconstruction. - Z(:,conj2lex) = K
%     i.e if Z_idx(f) = i, then k_f in K(:,f) is in position i in Z
% 
% * cci_k - conjugate center index of the set


Z_cci    = zeros(1,max_order); % conjugate center index array
revlex2conj = cell(1,max_order);  % index sets converting lex set to conj set
conj2revlex = cell(1,max_order);  % index sets converting conj set to lex set

for k = 1:max_order
    I = conjugate_flip(l_i,l_r);
    % Multi_indices in reverse lexicographical ordering
    K = flip(sortrows(<a href="../../../Library/Features/misc/nsumk.html">nsumk</a>(l_r+2*l_i,k,'nonnegative')).',2);
    Y = K(I,:);
    Exempt      = all(K-Y==0);
    Y(:,Exempt) = [];
    
    %Put m,m_c next to each other
    Z          = [K(:,~Exempt);Y];
    Z          = reshape(Z, size(K,1),[]);
    
    %index out all the combos of m, bar(m) that appear twice
    [~,Z_ia,~] = unique(Z.','rows');
    [~,Z_Ia]   = sort(Z_ia);    
    Z     = Z(:,Z_ia(Z_Ia));
    
    % sort the remaining multi-indices
    idx_1 = 1:2:size(Y,2);
    idx_2 = size(Y,2)-idx_1+1;
    Z     = [Z(:,idx_1),K(:,Exempt),Z(:,idx_2)];
    
    % conjugate center index
    cci_k = sum(Exempt,2) + length(idx_1); 

    % index arrays
    [~,~,conj2lex_k] = intersect(K.',Z.','rows','stable');
    [~,~,lex2conj_k] = intersect(Z.',K.','rows','stable');
    
    conj2revlex{k} = conj2lex_k.';
    revlex2conj{k} = lex2conj_k.';
    Z_cci(k)    = cci_k;
end

conjugate.conj2revlex = conj2revlex;
conjugate.revlex2conj = revlex2conj;
conjugate.Z_cci    = Z_cci;
conjugate.l_i      = l_i;
conjugate.l_r      = l_r;
end

function [idx] = conjugate_flip(l_i,l_r)
%%
% This function computes and index array that flips the conjugate coordinate directions  
% Conjugate coordinate directions are defined in $\textit{Explicit Kernel
% Extraction and Proof ofSymmetries of SSM Coefficients - Multi-Indexversion}$

idx = reshape(1:2*l_i,2,[]);
idx = reshape(flip(idx),1,[]);
idx = [idx,2*l_i+1:(2*l_i+l_r)];
end
            ##### SOURCE END #####
        --></body></html></body></html>