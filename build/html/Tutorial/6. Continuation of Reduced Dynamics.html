
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><body><div class="banner"><a href="../index.html"><img alt="Logo" class="logo" src="../logo.png" style="float:right" width="200"/></a></div><html><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--

                    This HTML was auto-generated from MATLAB code.
                    To make changes, update the MATLAB code and republish this document.
                --><title>Continuation of the ROM</title><meta content="MATLAB 9.14" name="generator"/><link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/><meta content="2023-09-07" name="DC.date"/><meta content="Continuation.m" name="DC.source"/><style type="text/css">
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

            html { min-height:100%; margin-bottom:1px; }
            html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
            html body td { vertical-align:top; text-align:left; }

            h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
            h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
            h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

            a { color:#005fce; text-decoration:none; }
            a:hover { color:#005fce; text-decoration:underline; }
            a:visited { color:#004aa0; text-decoration:none; }

            p { padding:0px; margin:0px 0px 20px; }
            img { padding:0px; margin:0px 0px 20px; border:none; }
            p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

            ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
            ul li { padding:0px; margin:0px 0px 7px 0px; }
            ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
            ul li ol li { list-style:decimal; }
            ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
            ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
            ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
            ol li ol li { list-style-type:lower-alpha; }
            ol li ul { padding-top:7px; }
            ol li ul li { list-style:square; }

            .content { font-size:1.2em; line-height:140%; padding: 20px; }

            pre, code { font-size:12px; }
            tt { font-size: 1.2em; }
            pre { margin:0px 0px 20px; }
            pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
            pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
            pre.error { color:red; }

            @media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

            span.keyword { color:#0000FF }
            span.comment { color:#228B22 }
            span.string { color:#A020F0 }
            span.untermstring { color:#B20000 }
            span.syscmd { color:#B28C00 }
            span.typesection { color:#A0522D }

            .footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
            .footer p { margin:0px; }
            .footer a { color:#878787; }
            .footer a:hover { color:#878787; text-decoration:underline; }
            .footer a:visited { color:#878787; }

            table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
            table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

            .center {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 50%;
              }



        </style></head><body><div class="content"><h1>Continuation of the ROM</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#5">Build continuation problem</a></li><li><a href="#10">Start continuation</a></li></ul></div><p>SSMTool integrates the Continuation Core (COCO) Toolbox, to analyse the reduced dynamical system on the SSM. This allows for the detection and continuation of families of periodic orbits, equilibrium points and bifurcations of different types. As the reduced dynamics constitute a low-dimensional dynamical system, COCO is the perfect tool for such an analysis. It is very versatile and for small dynamical systems such as the reduced dynamics it  operates fast. The combination of model reduction to the invariant SSMs and COCO for the in depth analyisis of the ROM on the manifold thus results in a highly efficient and accurate routine for model reduction. The ROMs are exact due to the invariance of the SSM and their analysis with COCO is fast due to their low dimensionality.</p><p>Detailed information and documentation can be found in the <a href="https://sourceforge.net/p/cocotools/wiki/Home/">online knowledgebase</a> for COCO.</p><p>For the analysis and continuation of two-dimensional invariant tori, the continuation toolbox <a href="https://github.com/mingwu-li/torus_collocation">TOR</a> is used. This toolbox is based on COCO and thus naturally integrates into the syntax used for the routines implemented for coupling SSMTool with COCO.</p><p>A general <a href="../Library/Features/Wrappers.html">Wrapper</a> couples COCO to the dynamical system class, for the analysis of the full dynamical systems and the comparison of full system results to the ones obtained directly from the ROM.</p><p>For using these routines for the continuation of the reduced dynamics, several Wrappers in the <a href="../Library/SSM/SSM.html">SSM</a> class serve for the intuitive and straightforward handling of the continuation problems which are constructed on the SSM. Generally these wrapper-functions follow the syntax and naming conventions of COCO. On the syntax of the continuation toolbox The basic setup for the continuation of the ROM given by the reduced dynamics on an SSM looks as follows. The <span class="MathJax_Preview"><img alt="$M$" src="Continuation_eq09319732146067371049-Rescaled.png" style="width: 14.399999999999999px; height: auto;"/></span><script type="math/tex">M</script>-dimensional ODE provided by the reduced dynamics are written in terms of the expansion computed by SSMTool:</p><p><span class="MathJax_Preview"><img alt="$$\dot{\mathbf{p}} =   \sum_{\mathbf{m}\in \mathbf{N}^M} \mathbf{R}_{\mathbf{m}}
\mathbf{p}^{\mathbf m} + \epsilon \sum_{\mathbf{m}\in \mathbf{N}^M, m \geq 1}
\sum_{\kappa \in \mathbf{Z}} \mathbf{S}_{\mathbf{m},\kappa } e^{i \kappa \Omega
t }\mathbf{p}^{\mathbf m}$$" src="Continuation_eq14342983797947832629-Rescaled.png" style="width: 267.59999999999997px; height: auto;"/></span><script type="math/tex">\dot{\mathbf{p}} =   \sum_{\mathbf{m}\in \mathbf{N}^M} \mathbf{R}_{\mathbf{m}}
\mathbf{p}^{\mathbf m} + \epsilon \sum_{\mathbf{m}\in \mathbf{N}^M, m \geq 1}
\sum_{\kappa \in \mathbf{Z}} \mathbf{S}_{\mathbf{m},\kappa } e^{i \kappa \Omega
t }\mathbf{p}^{\mathbf m}</script></p><p>The autonomous coefficients of the reduced dynamics <span class="MathJax_Preview"><img alt="$\mathbf{R_m}$" src="Continuation_eq04333112817243735904-Rescaled.png" style="width: 20.4px; height: auto;"/></span><script type="math/tex">\mathbf{R_m}</script> and of the SSM expansion <span class="MathJax_Preview"><img alt="$\mathbf{W_m}$" src="Continuation_eq12315308127707716855-Rescaled.png" style="width: 25.2px; height: auto;"/></span><script type="math/tex">\mathbf{W_m}</script> do not change if the forcing frequency or amplitude are changed. Therefore the autonomous SSM (we call the object representing the manifold <tt>S</tt> ) can be precomputed  up to a desired order as</p><pre class="codeinput">[W,R] = S.<a href="../Library/Manifold/compute_whisker.html">compute_whisker</a>(order);
        </pre><p>Consequently the ODE for the ROM is encoded as</p><pre class="codeinput">fdata   = struct(<span class="string">'order'</span>, order,<span class="string">'R'</span>,R,<span class="string">'W'</span>,W);
odefun  = @(t,x,p) <a href="../Library/SSM/private/ode_2DSSM_cartesian.html">ode_2DSSM_cartesian</a>(t,x,p,fdata,S);
        </pre><p>To speed up the process of finding nearby solutions, it is recommended to provide the Jacobians of the ROM, both with respect to the parametrisation coordinates, as well as with respect to external parameters. These are then used to get an approximate initial guess for nearby solutions of the continuation problems.</p><pre class="codeinput">odefun_dx = @(t,x,p) <a href="../Library/SSM/private/ode_2DSSM_cartesian_DFDX.html">ode_2DSSM_cartesian_DFDX</a>(t,x,p,fdata,S);
odefun_dp = @(t,x,p) <a href="../Library/SSM/private/ode_2DSSM_cartesian_DFDP.html">ode_2DSSM_cartesian_DFDP</a>(t,x,p,fdata,S);
        </pre><p>Next we build the continuation problem structure <tt>prob</tt>. It contains all information about the dynamical system and the parameters used for continuation. As the ROM which is analysed is non-autonomous and our implementation of it is not vectorized, we set the corresponding parameters to false.</p><h2 id="5">Build continuation problem</h2><pre class="codeinput">prob = coco_prob();
prob = <a href="../Library/Features/Wrappers/cocoWrapper/cocoSet.html">cocoSet</a>(obj.contOptions, prob); <span class="comment">%set default options</span>
prob = <a href="../Library/Features/Wrappers/cocoWrapper/cocoSet.html">cocoSet</a>(prob, <span class="string">'ode'</span>, <span class="string">'autonomous'</span>, false);
prob = <a href="../Library/Features/Wrappers/cocoWrapper/cocoSet.html">cocoSet</a>(prob, <span class="string">'ode'</span>, <span class="string">'vectorized'</span>, false);
        </pre><p>Consequently we provide the continuation variables to the structure. This includes the ODE and its jacobians, initial conditions and the initial parameter values.</p><pre class="codeinput">coll_args = {odefun,odefun_dx,odefun_dp, t0, z0, {<span class="string">'om'</span>,<span class="string">'eps'</span>}, p0};
        </pre><p>Then we look for an initial solution guess. In this case, we wish to obtain and continue periodic orbits of the dynamical systems. So we have to compute an initial periodic orbit, from which a family of periodic orbits is later computed via continuation.</p><pre class="codeinput">prob = ode_isol2po(prob, <span class="string">''</span>, coll_args{:});
        </pre><p>The structure can be customized by adding functions, which are evaluated during continuation. This can be employed to map the parametrisation coordinates onto full physical coordinates online. For each forcing frequency the SSM parametrisation is computed</p><p><span class="MathJax_Preview"><img alt="$$\mathbf{ W}_\epsilon(\mathbf p,\Omega t) = \mathbf W (\mathbf p ) + \epsilon
\mathbf{X} (\mathbf p,\Omega t) + \cdots$$" src="Continuation_eq12917677622619248118-Rescaled.png" style="width: 214.79999999999998px; height: auto;"/></span><script type="math/tex">\mathbf{ W}_\epsilon(\mathbf p,\Omega t) = \mathbf W (\mathbf p ) + \epsilon
\mathbf{X} (\mathbf p,\Omega t) + \cdots</script></p><p>The coefficients of the Fourier expansion of <span class="MathJax_Preview"><img alt="$\mathbf{X}$" src="Continuation_eq02260506203804848401-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{X}</script> and <span class="MathJax_Preview"><img alt="$\mathbf{S}$" src="Continuation_eq17705281529142768610-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">\mathbf{S}</script> are dependent on the forcing frequency via the <a href="../Theory/4.%20SSM-Computation.html">non-autonomous invariance equation</a>. Therefore they have to be recomputed if the forcing frequency is changed. We add a function to the continuation problem to map the solution points in parametrisation space onto physical coordinates, using <span class="MathJax_Preview"><img alt="$\mathbf{W}_\epsilon$" src="Continuation_eq07602178423321565983-Rescaled.png" style="width: 19.2px; height: auto;"/></span><script type="math/tex">\mathbf{W}_\epsilon</script>. As <span class="MathJax_Preview"><img alt="$\mathbf{X}$" src="Continuation_eq02260506203804848401-Rescaled.png" style="width: 12.0px; height: auto;"/></span><script type="math/tex">\mathbf{X}</script> cannot be precomputed, it is internally attached to the problem structure - and then evaluated in the <tt>full_amplitude</tt> function.</p><pre class="codeinput"><span class="comment">% Convert reduced results to full while contination to avoid overhead of SSM</span>
<span class="comment">% computations</span>
ampData = struct(<span class="string">'W'</span>,W,<span class="string">'nt'</span>,nt,<span class="string">'outdof'</span>,outdof);
numoutdof   = numel(outdof);

<span class="comment">% Specify DOFs of output</span>
ampNames    = cell(1, numoutdof+1);
ampNames{end} = <span class="string">'Znorm'</span>;
<span class="keyword">for</span> k = 1:numoutdof
    ampNames{k} = strcat(<span class="string">'amp'</span>,num2str(outdof(k)));
<span class="keyword">end</span>

ampfunc = @(prob,data,u) full_amplitude(prob,data,u,obj);
prob = coco_add_func(prob, <span class="string">'amp'</span>, ampfunc, ampData, <span class="string">'regular'</span>, ampNames,<span class="keyword">...</span>
    <span class="string">'uidx'</span>, uidx([maps.x0_idx, maps.p_idx]));
        </pre><p>To initiate the continuation, we set the continuation variables, and a parameter-range over which they continuation is to be performed. In this case we choose to continue the forcing frequency. The output bifurcation data <tt>bd</tt> contains the family of periodic orbits, starting at the initially computed orbit and continuing along a family as the forcing frequency is varied.</p><h2 id="10">Start continuation</h2><pre class="codeinput">cont_args = {[{<span class="string">'om'</span>},{<span class="string">'po.period'</span>},ampNames(:)'],parRange};

<span class="comment">% Release parameters for continuation</span>
bd = coco(prob, <span class="string">'my_continuation_run'</span>, [], cont_args{:});
        </pre><p>As explained in <a href="../Theory/4.%20SSM-Computation.html">the tutorial on computing SSMs</a>, in many cases only a leading order approximation to the invariant manifold has to be computed. In this case the coefficients of <span class="MathJax_Preview"><img alt="$\mathbf{S}$" src="Continuation_eq17705281529142768610-Rescaled.png" style="width: 7.199999999999999px; height: auto;"/></span><script type="math/tex">\mathbf{S}</script> and $\mathbf{X}$do not exhibit dependence on the forcing frequency. The ROM can thus be precomputed and after the continuation run has finished, the obtained solutions are mapped back to physical coordinates via the leading order approximation of the SSM parametrisation.</p><p>This basic syntax can be supplemented with various options to customize the continuation routine. Examples of this can be found in the following Wrapper methods:</p><div><ul><li><a href="../Library/SSM/extract_Stability_Diagram.html">extract_Stability_Diagram</a></li><li><a href="../Library/SSM/FRC_cont_ep.html">FRC_cont_ep</a></li><li><a href="../Library/SSM/FRC_cont_po.html">FRC_cont_po</a></li><li><a href="../Library/SSM/SSM_cont_ep.html">SSM_cont_ep</a></li><li><a href="../Library/SSM/SSM_cont_po.html">SSM_cont_po</a></li><li><a href="../Library/SSM/SSM_epSweeps.html">SSM_epSweeps</a></li><li><a href="../Library/SSM/SSM_poSweeps.html">SSM_poSweeps</a></li></ul></div><p>If a bifurcation point, periodic orbit, invariant torus, branch point or similar is found in a continuation run, it can then be used as a starting point for a new continuation run to detect families of such special features. For the handling of these cases a list of Wrappers are provided:</p><div><ul><li><a href="../Library/SSM/SSM_BP2ep.html">SSM_BP2ep</a></li><li><a href="../Library/SSM/SSM_BP2po.html">SSM_BP2po</a></li><li><a href="../Library/SSM/SSM_BP2tor.html">SSM_BP2tor</a></li><li><a href="../Library/SSM/SSM_ep2ep.html">SSM_ep2ep</a></li><li><a href="../Library/SSM/SSM_ep2HB.html">SSM_ep2HB</a></li><li><a href="../Library/SSM/SSM_ep2SN.html">SSM_ep2SN</a></li><li><a href="../Library/SSM/SSM_HB2po.html">SSM_HB2po</a></li><li><a href="../Library/SSM/SSM_isol2ep.html">SSM_isol2ep</a></li><li><a href="../Library/SSM/SSM_isol2po.html">SSM_isol2po</a></li><li><a href="../Library/SSM/SSM_po2PD.html">SSM_po2PD</a></li><li><a href="../Library/SSM/SSM_po2po.html">SSM_po2po</a></li><li><a href="../Library/SSM/SSM_po2SN.html">SSM_po2SN</a></li><li><a href="../Library/SSM/SSM_po2TR.html">SSM_po2TR</a></li><li><a href="../Library/SSM/SSM_tor2tor.html">SSM_tor2tor</a></li><li><a href="../Library/SSM/SSM_TR2tor.html">SSM_TR2tor</a></li></ul></div><p class="footer"><br/><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2023a</a><br/></p></div><!--
            ##### SOURCE BEGIN #####
            %% Continuation of the ROM
%
%%
% SSMTool integrates the Continuation Core (COCO) Toolbox, to analyse the reduced 
% dynamical system on the SSM. This allows for the detection and continuation 
% of families of periodic orbits, equilibrium points and bifurcations of different 
% types. As the reduced dynamics constitute a low-dimensional dynamical system, 
% COCO is the perfect tool for such an analysis. It is very versatile and for 
% small dynamical systems such as the reduced dynamics it  operates fast. The 
% combination of model reduction to the invariant SSMs and COCO for the in depth 
% analyisis of the ROM on the manifold thus results in a highly efficient and 
% accurate routine for model reduction. The ROMs are exact due to the invariance 
% of the SSM and their analysis with COCO is fast due to their low dimensionality.
% 
% Detailed information and documentation can be found in the <https://sourceforge.net/p/cocotools/wiki/Home/ 
% online knowledgebase> for COCO.
% 
% For the analysis and continuation of two-dimensional invariant tori, the continuation 
% toolbox <https://github.com/mingwu-li/torus_collocation TOR> is used. This toolbox 
% is based on COCO and thus naturally integrates into the syntax used for the 
% routines implemented for coupling SSMTool with COCO.
% 
% A general <../Library/Features/Wrappers.html Wrapper> couples COCO to the dynamical system class, 
% for the analysis of the full dynamical systems and the comparison of full system 
% results to the ones obtained directly from the ROM. 
% 
% For using these routines for the continuation of the reduced dynamics, several 
% Wrappers in the <../Library/SSM/SSM.html SSM> class serve for the intuitive and straightforward 
% handling of the continuation problems which are constructed on the SSM. Generally 
% these wrapper-functions follow the syntax and naming conventions of COCO.
% On the syntax of the continuation toolbox
% The basic setup for the continuation of the ROM given by the reduced dynamics 
% on an SSM looks as follows. The $M$-dimensional ODE provided by the reduced 
% dynamics are written in terms of the expansion computed by SSMTool:
% 
% $$\dot{\mathbf{p}} =   \sum_{\mathbf{m}\in \mathbf{N}^M} \mathbf{R}_{\mathbf{m}} 
% \mathbf{p}^{\mathbf m} + \epsilon \sum_{\mathbf{m}\in \mathbf{N}^M, m \geq 1}  
% \sum_{\kappa \in \mathbf{Z}} \mathbf{S}_{\mathbf{m},\kappa } e^{i \kappa \Omega 
% t }\mathbf{p}^{\mathbf m}$$
% 
% The autonomous coefficients of the reduced dynamics $\mathbf{R_m}$ and of 
% the SSM expansion $\mathbf{W_m}$ do not change if the forcing frequency or amplitude 
% are changed. Therefore the autonomous SSM (we call the object representing 
% the manifold |S| ) can be precomputed  up to a desired order as

[W,R] = S.<a href="../Library/Manifold/compute_whisker.html">compute_whisker</a>(order);
%% 
% Consequently the ODE for the ROM is encoded as

fdata   = struct('order', order,'R',R,'W',W);
odefun  = @(t,x,p) <a href="../Library/SSM/private/ode_2DSSM_cartesian.html">ode_2DSSM_cartesian</a>(t,x,p,fdata,S);
%% 
% To speed up the process of finding nearby solutions, it is recommended to 
% provide the Jacobians of the ROM, both with respect to the parametrisation coordinates, 
% as well as with respect to external parameters. These are then used to get an 
% approximate initial guess for nearby solutions of the continuation problems.

odefun_dx = @(t,x,p) <a href="../Library/SSM/private/ode_2DSSM_cartesian_DFDX.html">ode_2DSSM_cartesian_DFDX</a>(t,x,p,fdata,S);
odefun_dp = @(t,x,p) <a href="../Library/SSM/private/ode_2DSSM_cartesian_DFDP.html">ode_2DSSM_cartesian_DFDP</a>(t,x,p,fdata,S);
%% 
% Next we build the continuation problem structure |prob|. It contains all information 
% about the dynamical system and the parameters used for continuation. As the 
% ROM which is analysed is non-autonomous and our implementation of it is not 
% vectorized, we set the corresponding parameters to false.

%% Build continuation problem

prob = coco_prob();
prob = <a href="../Library/Features/Wrappers/cocoWrapper/cocoSet.html">cocoSet</a>(obj.contOptions, prob); %set default options 
prob = <a href="../Library/Features/Wrappers/cocoWrapper/cocoSet.html">cocoSet</a>(prob, 'ode', 'autonomous', false);
prob = <a href="../Library/Features/Wrappers/cocoWrapper/cocoSet.html">cocoSet</a>(prob, 'ode', 'vectorized', false);
%% 
% Consequently we provide the continuation variables to the structure. This 
% includes the ODE and its jacobians, initial conditions and the initial parameter 
% values.

coll_args = {odefun,odefun_dx,odefun_dp, t0, z0, {'om','eps'}, p0};
%% 
% Then we look for an initial solution guess. In this case, we wish to obtain 
% and continue periodic orbits of the dynamical systems. So we have to compute 
% an initial periodic orbit, from which a family of periodic orbits is later computed 
% via continuation.

prob = ode_isol2po(prob, '', coll_args{:});
%% 
% The structure can be customized by adding functions, which are evaluated during 
% continuation. This can be employed to map the parametrisation coordinates onto 
% full physical coordinates online. For each forcing frequency the SSM parametrisation 
% is computed
% 
% $$\mathbf{ W}_\epsilon(\mathbf p,\Omega t) = \mathbf W (\mathbf p ) + \epsilon 
% \mathbf{X} (\mathbf p,\Omega t) + \cdots$$
% 
% The coefficients of the Fourier expansion of $\mathbf{X}$ and $\mathbf{S}$ 
% are dependent on the forcing frequency via the <../Theory/4.%20SSM-Computation.html non-autonomous 
% invariance equation>. Therefore they have to be recomputed if the forcing frequency 
% is changed. We add a function to the continuation problem to map the solution 
% points in parametrisation space onto physical coordinates, using $\mathbf{W}_\epsilon$. 
% As $\mathbf{X}$ cannot be precomputed, it is internally attached to the problem 
% structure - and then evaluated in the |full_amplitude| function.

% Convert reduced results to full while contination to avoid overhead of SSM
% computations
ampData = struct('W',W,'nt',nt,'outdof',outdof);
numoutdof   = numel(outdof);

% Specify DOFs of output
ampNames    = cell(1, numoutdof+1);
ampNames{end} = 'Znorm';
for k = 1:numoutdof
    ampNames{k} = strcat('amp',num2str(outdof(k)));
end

ampfunc = @(prob,data,u) full_amplitude(prob,data,u,obj);
prob = coco_add_func(prob, 'amp', ampfunc, ampData, 'regular', ampNames,...
    'uidx', uidx([maps.x0_idx, maps.p_idx]));
%% 
% To initiate the continuation, we set the continuation variables, and a parameter-range 
% over which they continuation is to be performed. In this case we choose to continue 
% the forcing frequency. The output bifurcation data |bd| contains the family 
% of periodic orbits, starting at the initially computed orbit and continuing 
% along a family as the forcing frequency is varied.

%% Start continuation
cont_args = {[{'om'},{'po.period'},ampNames(:)'],parRange};

% Release parameters for continuation
bd = coco(prob, 'my_continuation_run', [], cont_args{:});
%% 
% As explained in <../Theory/4.%20SSM-Computation.html the tutorial on computing SSMs>, in many 
% cases only a leading order approximation to the invariant manifold has to be 
% computed. In this case the coefficients of $\mathbf{S}$ and $\mathbf{X}$do not 
% exhibit dependence on the forcing frequency. The ROM can thus be precomputed 
% and after the continuation run has finished, the obtained solutions are mapped 
% back to physical coordinates via the leading order approximation of the SSM 
% parametrisation. 
% 
% This basic syntax can be supplemented with various options to customize the 
% continuation routine. Examples of this can be found in the following Wrapper 
% methods:
%% 
% * <../Library/SSM/extract_Stability_Diagram.html extract_Stability_Diagram>
% * <../Library/SSM/FRC_cont_ep.html FRC_cont_ep>
% * <../Library/SSM/FRC_cont_po.html FRC_cont_po>
% * <../Library/SSM/SSM_cont_ep.html SSM_cont_ep>
% * <../Library/SSM/SSM_cont_po.html SSM_cont_po>
% * <../Library/SSM/SSM_epSweeps.html SSM_epSweeps>
% * <../Library/SSM/SSM_poSweeps.html SSM_poSweeps>
%% 
% If a bifurcation point, periodic orbit, invariant torus, branch point or similar 
% is found in a continuation run, it can then be used as a starting point for 
% a new continuation run to detect families of such special features. For the 
% handling of these cases a list of Wrappers are provided:
%% 
% * <../Library/SSM/SSM_BP2ep.html SSM_BP2ep>
% * <../Library/SSM/SSM_BP2po.html SSM_BP2po>
% * <../Library/SSM/SSM_BP2tor.html SSM_BP2tor>
% * <../Library/SSM/SSM_ep2ep.html SSM_ep2ep>
% * <../Library/SSM/SSM_ep2HB.html SSM_ep2HB>
% * <../Library/SSM/SSM_ep2SN.html SSM_ep2SN>
% * <../Library/SSM/SSM_HB2po.html SSM_HB2po>
% * <../Library/SSM/SSM_isol2ep.html SSM_isol2ep>
% * <../Library/SSM/SSM_isol2po.html SSM_isol2po>
% * <../Library/SSM/SSM_po2PD.html SSM_po2PD>
% * <../Library/SSM/SSM_po2po.html SSM_po2po>
% * <../Library/SSM/SSM_po2SN.html SSM_po2SN>
% * <../Library/SSM/SSM_po2TR.html SSM_po2TR>
% * <../Library/SSM/SSM_tor2tor.html SSM_tor2tor>
% * <../Library/SSM/SSM_TR2tor.html SSM_TR2tor>

            ##### SOURCE END #####
        --></body></html></body></html>